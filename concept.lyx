#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Koncepcja i projekt systemu
\end_layout

\begin_layout Standard
kod zarządzalny (testowane C#, F#), łatwy w użyciu, szybki start dla nuboof,
 wysoki poziom abstrakcji (wątki vs przesyłanie komunikatów, współdzielenie
 stanu vs erlang)
\end_layout

\begin_layout Standard
(komputery połączone siecią, które mogą komunikować się każdy z każdym,
 nie może być NAT).
 Biblioteka zapewnia szkielet/środowisko (framework?) do tworzenia aplikacji
 rozproszonych.
 Aplikacja taka musi zostać rozdystrybuowana na węzły w klastrze przez użytkowni
ka.
 Zakładamy, że na węzłach obliczeniowych [to określenie mi się podoba] znajduje
 się zgodna binarnie wersja aplikacji, tj.
 każdy z węzłów może wykonać dowolną metodę z dowolnej klasy będącej częścią
 aplikacji.
 
\end_layout

\begin_layout Standard
[słabo, wiem ;p] 
\end_layout

\begin_layout Standard
Ponadto na węzłach mogą działać dodatkowe usługi.
 
\end_layout

\begin_layout Section
Usługa odnajdywania węzłów
\end_layout

\begin_layout Standard
Odkrywanie węzłów w sieci realizowane jest za pomocą usługi Service Discovery,
 która działa na jednym z węzłów.
 Dołączające się węzły muszą znać adres serwera Service Discovery w celu
 zarejestrowania się w usłudze.
 Rejestracja/wyrejestrowanie się węzła powoduje rozesłania powiadomienia
 o tym fakcie do wszystkich pozostałych węzłów w klastrze.
 Usługa ta okresowo monitoruje obciążenie węzłów.
 W przypadku braku odpowiedzi stwierdzana jest awaria węzła i jest on wyrejestro
wywany z klastra.
 
\end_layout

\begin_layout Subsection
ConnectionManager
\end_layout

\begin_layout Standard
Zarządca połączeń
\end_layout

\begin_layout Section
Rozproszona pamięć współdzielona
\end_layout

\begin_layout Standard
co to i po co
\end_layout

\begin_layout Subsection
Kolekcje rozproszone
\end_layout

\begin_layout Standard
Zapewniają łatwą w zrozumieniu i wykorzystaniu abstrakcję.
\end_layout

\begin_layout Standard
Distributed list, dictionary, counter
\end_layout

\begin_layout Subsection
Operacje zbiorcze
\end_layout

\begin_layout Standard
bo chcemy minimalizować narzuty komunikacyjne
\end_layout

\begin_layout Section
Rozproszony wątek
\end_layout

\begin_layout Standard
Jednostką przetwarzania w systemie jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Rozproszony wątek
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
nazwa?
\end_layout

\end_inset

.
 Jest on tworzony na podstawie statycznej metody, która przyjmuje dowolną,
 liczbę parametrów i zwraca wartość.
 Wynik przechwytywany jest przez środowisko i udostępniany do odczytu na
 węźle, który zlecił wykonanie wątku.
 Rozproszony wątek może zostać wykonany na dowolnym węźle obliczeniowym
 oraz uruchamiać kolejne rozproszone wątki.
 Decyzja o wyborze miejsca wykonania wątku podejmowana jest z wykorzystaniem
 lokalnej wiedzy o stanie klastra przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Planistę
\end_layout

\end_inset

(więcej o tym dalej, bo pisanie o interefejsie i własnym schedulerze to
 chyba nie tu).
 
\end_layout

\begin_layout Subsection
Typy w systemie
\end_layout

\begin_layout Standard
W trakcie projektowania systemu założono, że wszystkie typy przesyłane pomiędzy
 węzłami muszą być serializowalne (posiadać atrybut 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
Serializable
\end_layout

\end_inset

).
\end_layout

\begin_layout Section
Wykonawca
\end_layout

\begin_layout Standard
Wykonywanie wątków zarówno zdalne jak i lokalne jest zarządzane przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Wykonawców
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Wykonawca lokalny
\end_layout

\begin_layout Standard
Wszystkie wątki wykonywane lokalnie (zarówno te które pochodzą z lokalnego
 węzła jak i te zlecone przez inny węzeł) są zarządzane przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Wykonawców lokalnych
\end_layout

\end_inset

.
 Do ich (wykonawcy) zadań należą:
\end_layout

\begin_layout Itemize
rozpocząć przetwarzanie, 
\end_layout

\begin_layout Itemize
przekierować parametry, 
\end_layout

\begin_layout Itemize
przechwycić wyjątki,
\end_layout

\begin_layout Itemize
po zakończeniu przetwarzania udostępnia wyniki wyższym warstwom.
\end_layout

\begin_layout Subsection
Wykonawca zdalny
\end_layout

\begin_layout Standard
Do opakowania zdalnego uruchomienia 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Rozproszonego wątku
\end_layout

\end_inset

 zastosowany został 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Wykonawca zdalny
\end_layout

\end_inset

.
 Zleca on wykonanie zadania [wyspecyfikowanemu] węzłowi, oraz monitoruje
 stan wykonania zadania (zakończenie, wystąpienie błędów).
 Jest on również odpowiedzialny za odebranie wyniku przetwarzania i udostępnieni
e ich wyższym warstwom.
\end_layout

\begin_layout Section
Planista
\end_layout

\begin_layout Standard
Elementem systemu decydującym o wyborze miejsca wykonywania 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Rozproszonego wątku
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
nazwa?
\end_layout

\end_inset

 jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Planista
\end_layout

\end_inset

.
 Każda jego realizacja musi być oparta na zdefiniowanym interfejsie.
 Dzięki temu użytkownik może przygotować własną implementację 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
Planisty
\end_layout

\end_inset

 dostosowaną do prowadzonego przetwarzania lub wybrać jedną z dostarczonych
 razem z biblioteką.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Musi on implementować interfejs 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
IScheduler
\end_layout

\end_inset

.
 Pozwala to zastosować implementację Planisty dostosowaną do potrzeb przetwarzan
ia i jest jednym z istotnych elementów modułowości sys
\end_layout

\end_inset


\end_layout

\begin_layout Section
Logowanie zdarzeń
\end_layout

\begin_layout Standard
srhghsdhf
\end_layout

\begin_layout Subsection
OpenXES
\end_layout

\begin_layout Standard
nasza implementacja standardu
\end_layout

\begin_layout Standard
process mining
\end_layout

\begin_layout Standard
much image
\end_layout

\begin_layout Standard
Wizualizacja logów
\end_layout

\begin_layout Standard
Disco
\end_layout

\end_body
\end_document
