#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Koncepcja i projekt systemu
\end_layout

\begin_layout Standard
kod zarządzalny (testowane C#, F#), łatwy w użyciu, szybki start dla nuboof,
 wysoki poziom abstrakcji (wątki vs przesyłanie komunikatów, współdzielenie
 stanu vs erlang)
\end_layout

\begin_layout Standard
(komputery połączone siecią, które mogą komunikować się każdy z każdym,
 nie może być NAT).
 Biblioteka zapewnia szkielet/środowisko (framework?) do tworzenia aplikacji
 rozproszonych.
 Aplikacja taka musi zostać rozdystrybuowana na węzły w klastrze przez użytkowni
ka.
 Zakładamy, że na węzłach obliczeniowych [to określenie mi się podoba] znajduje
 się zgodna binarnie wersja aplikacji, tj.
 każdy z węzłów może wykonać dowolną metodę z dowolnej klasy będącej częścią
 aplikacji.
 
\end_layout

\begin_layout Standard
[słabo, wiem ;p] 
\end_layout

\begin_layout Standard
Ponadto na węzłach mogą działać dodatkowe usługi.
 
\end_layout

\begin_layout Section
Usługa odnajdywania węzłów
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zbyt specyficznie na twarz - najpierw trzeba opisać, że jest usługa jaki
 jest jej cel a dopiero potem propozycje najprostszej realizacji.
 W ogólności ta usługa mogłaby być mocno powiązana ze storage i oparta na
 DHT.
 [done]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Jednym z podstawowych założeń jest posiadanie przez wszystkie węzły w systemie
 lokalnego obrazu stanu wszystkich innych węzłów w kalstrze.
 Informacje dotyczące stanu poszczególnych węzłów są dostarczane przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usługę odnajdywania węzłów
\end_layout

\end_inset

.
 Usługa ta powinna obsługiwać sytuację rejestracji oraz wyrejestrowania
 się węzłów.
 System z założenia abstrachuje od sposobu realizacji tej usługi (czy będzie
 to system zcentralizowany, czy rozproszony np.
 oparty na algorytmie plotkującym).
 W związku z pełnioną rolą 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usługa odnajdywania węzłów
\end_layout

\end_inset

 jest kluczowym elementem przy implementacji wykrywania awarii węzłów w
 klastrze.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Odkrywanie węzłów w sieci realizowane jest za pomocą usługi Service Discovery,
 która działa na jednym z węzłów.
 Dołączające się węzły muszą znać adres serwera Service Discovery w celu
 zarejestrowania się w usłudze.
 Rejestracja/wyrejestrowanie się węzła powoduje rozesłania powiadomienia
 o tym fakcie do wszystkich pozostałych węzłów w klastrze.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
chyba nie za bardzo: Usługa ta okresowo monitoruje obciążenie węzłów.
 W przypadku braku odpowiedzi stwierdzana jest awaria węzła i jest on wyrejestro
wywany z klastra.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zarządca połączeń
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
ConnectionManager
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Każdy węzeł powinien przechowywać lokalnie obraz klastra, aby w momencie,
 kiedy zajdzie potrzeba zlecenia zadania jednemu ze 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zdalnych wykonawców
\end_layout

\end_inset

, nie musiał odpytywać usługi katalogowej.
 Tym zadaniem zajmuje się 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zarządca połączeń
\end_layout

\end_inset

.
 Posiada też dodatkowe informacje, które mogą przydać
\begin_inset space \space{}
\end_inset

się 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
planiście
\end_layout

\end_inset

, np.
 obciążenie węzłów.
\end_layout

\begin_layout Section
Rozproszony wątek
\end_layout

\begin_layout Standard
Jednostką przetwarzania w systemie jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
rozproszony wątek
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
nazwa?
\end_layout

\end_inset

.
 Jest on tworzony na podstawie statycznej metody, która przyjmuje dowolną,
 liczbę parametrów i zwraca wartość.
 Wynik przechwytywany jest przez środowisko i udostępniany do odczytu na
 węźle, który zlecił wykonanie wątku.
 Rozproszony wątek może zostać wykonany na dowolnym węźle obliczeniowym
 oraz uruchamiać kolejne rozproszone wątki.
 Decyzja o wyborze miejsca wykonania wątku podejmowana jest z wykorzystaniem
 lokalnej wiedzy o stanie klastra przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
planistę
\end_layout

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
(więcej o tym dalej, bo pisanie o interefejsie i własnym schedulerze to
 chyba nie tu).
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Typy w systemie
\end_layout

\begin_layout Standard
W trakcie projektowania systemu założono, że wszystkie typy przesyłane pomiędzy
 węzłami muszą być serializowalne (posiadać atrybut 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
Serializable
\end_layout

\end_inset

).
\end_layout

\begin_layout Section
Wykonawca
\end_layout

\begin_layout Standard
W celu ograniczenia liczby zadań pełnionych przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszony wątek
\end_layout

\end_inset

 zdefiniowano 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wykonawcę
\end_layout

\end_inset

 - element odpowiedzialny za wykonywanie wątków zarówno zdalne jak i lokalne.
 Zastosowanie takiej abstrakcji pozwala potraktować przetwarzanie lokalne
 oraz zdalne w podobny sposób.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Czy to ma sens?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wykonawca lokalny
\end_layout

\begin_layout Standard
Wszystkie wątki wykonywane lokalnie (zarówno te które pochodzą z lokalnego
 węzła jak i te zlecone przez inny węzeł) są zarządzane przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
wykonawców lokalnych
\end_layout

\end_inset

.
 Do zadań 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wykonawcy lokalnego
\end_layout

\end_inset

 należą:
\end_layout

\begin_layout Itemize
rozpoczęcie przetwarzania, 
\end_layout

\begin_layout Itemize
przekierowanie parametrów, 
\end_layout

\begin_layout Itemize
przechwycenie wyjątków,
\end_layout

\begin_layout Itemize
udostępnienie wyników wyższym warstwom po zakończeniu przetwarzania.
\end_layout

\begin_layout Subsection
Wykonawca zdalny
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Coś, że niezbędna jest abstrakcja zdalnego wykonania w celu ładnie poukładanego
 kodu (Single Responsibility Class itp.)
\end_layout

\end_inset

Abstrakcją zdalnego uruchomienia 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
rozproszonego wątku
\end_layout

\end_inset

 jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
wykonawca zdalny
\end_layout

\end_inset

.
 Zleca on wykonanie zadania 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[wyspecyfikowanemu]
\end_layout

\end_inset

węzłowi wybranemu przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
planistę
\end_layout

\end_inset

 oraz monitoruje stan wykonania zadania (zakończenie, wystąpienie błędów).
 Jest on również odpowiedzialny za odebranie wyniku przetwarzania i udostępnieni
e ich wyższym warstwom.
\end_layout

\begin_layout Section
Planista
\end_layout

\begin_layout Standard
Elementem systemu decydującym o wyborze miejsca wykonywania 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
rozproszonego wątku
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
nazwa?
\end_layout

\end_inset

 jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
planista
\end_layout

\end_inset

.
 Każda jego realizacja musi być oparta na zdefiniowanym interfejsie.
 Dzięki temu użytkownik może przygotować własną implementację 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
planisty
\end_layout

\end_inset

 dostosowaną do prowadzonego przetwarzania lub wybrać jedną z dostarczonych
 razem z biblioteką.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Musi on implementować interfejs 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
IScheduler
\end_layout

\end_inset

.
 Pozwala to zastosować implementację Planisty dostosowaną do potrzeb przetwarzan
ia i jest jednym z istotnych elementów modułowości sys
\end_layout

\end_inset


\end_layout

\begin_layout Section
Rozproszona pamięć współdzielona
\begin_inset Note Note
status open

\begin_layout Plain Layout
nie podoba mi się do 
\begin_inset Quotes eld
\end_inset

rozproszona
\begin_inset Quotes erd
\end_inset

, bo w końcu testowaliśmy z 1 węzłem
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:concept-Rozproszona-pamięć-współdzielona"

\end_inset

Często w ramach przetwarzania rozproszonego zachodzi potrzeba komunikacji.
 W celu jej zapewnienia, jako część biblioteki 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Bluepath
\end_layout

\end_inset

, dostarczany jest mechanizm 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonej pamięci współdzielonej
\end_layout

\end_inset

 dalej nazywany równierz 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięcią współdzieloną
\end_layout

\end_inset

.
 Pamięć ta ma charakter pamięci masowej, a nie pamięci operacyjnej.
\begin_inset Note Note
status open

\begin_layout Plain Layout
(?) 
\end_layout

\end_inset

Zastosowanie takiego mechanizmu pozwala ukryć problemy komunikacyjne związane
 z wymianą danych i udostępnić programiście interfejs do którego jest przyzwycza
jony z programowania aplikacji równoległych.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Coś z tym zdaniem przed tą notatką jest nie tak.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W celu identyfikacji danych w pamięci współdzielonej zastosowano klucze.
 Klucz jest unikalnym ciągiem znaków jednoznacznie identyfikującym dane.
 W trakcie projektowania 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonej pamięci współdzielonej
\end_layout

\end_inset

 nie przewidziano zapewnienia hierarchii kluczy.
 Tego typu mechanizm, choć przydatny w pewnych przypadkach, może zostać
 dostarczony przez warstwy obudowujące dostęp do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Aby zapewnić wysoką użyteczność, oraz możliwość rozbudowy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 przewidziane zostały następujące operacje
\begin_inset Note Note
status open

\begin_layout Plain Layout
przeniosłem 'kodowe' nazwy operacji do implementacji
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize
zapis -- operacja zapisująca dane; w przypadku gdy podany klucz już istnieje
 operacja nie powiedzie się,
\end_layout

\begin_layout Itemize
zapis lub aktualizacja -- operacja zapisująca dane; w przypadku gdy podany
 klucz istnieje, wartość zostanie nadpisana,
\end_layout

\begin_layout Itemize
aktualizacja -- operacja aktualizująca dane -- powiedzie się tylko wtedy,
 gdy podany klucz został wcześniej utworzony w pamięci współdzielonej,
\end_layout

\begin_layout Itemize
pobranie -- operacja pobierająca dane -- powiedzie się tylko wtedy gdy podany
 klucz został wcześniej utworzony,
\end_layout

\begin_layout Itemize
usunięcie -- operacja usuwająca dane -- powiedzie się tylko wtedy gdy podany
 klucz został wcześniej utworzony w pamięci współdzielonej.
\end_layout

\begin_layout Standard
Operacje te, choć wystarczające w większości zastosowań, zostały rozwinięte
 o odpowiedniki operujące na wielu kluczach na raz - zostały one opisane
 w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Koncepcja-Operacje-zbiorcze"

\end_inset

.
\end_layout

\begin_layout Standard
Dzięki tak zdefiniowanej semantyce operacji na podstawie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonej pamięci współdzielonej
\end_layout

\end_inset

 można równierz zdefiniować bardziej złożone mechanizmy takie jak 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamki rozproszone
\end_layout

\end_inset

.
 Ponieważ część mechanizmów zapewniających realizację 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonej pamięci współdzielonej
\end_layout

\end_inset

 może posiadać wbudowane mechanizmy zapewniające 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamki rozproszone
\end_layout

\end_inset

 zdefiniowano 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozszerzoną pamięć współdzieloną
\end_layout

\end_inset

, której operacje zostały opisane w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Koncepcja-Zamki-rozproszone"

\end_inset

.
\end_layout

\begin_layout Subsection
Kolekcje rozproszone
\end_layout

\begin_layout Standard
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Pamięć współdzielona
\end_layout

\end_inset

 mimo tego, że zapewnia operacje niezbędne do komunikacji w trakcie przetwarzani
a, może okazać się mechanizmem o zbyt niskim poziomie abstrakcji.
 Efektem mogło by być wielokrotne pisanie przez programistę podobnych fragmentów
 kodu w celu obsługi 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Aby uniknąć takiej sytuacji wprowadzone zostały trzy podstawowe kolekcje
 oparte na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

: lista, słownik oraz licznik.
\end_layout

\begin_layout Paragraph
Lista rozproszona
\end_layout

\begin_layout Standard
na co pozwala, co zapewnia (operacje opisać w implementacji).
\end_layout

\begin_layout Paragraph
Słownik rozproszony
\end_layout

\begin_layout Standard
na co pozwala, co zapewnia (operacje opisać w implementacji).
\end_layout

\begin_layout Paragraph
Licznik rozproszony
\end_layout

\begin_layout Standard
na co pozwala, co zapewnia (operacje opisać w implementacji).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zapewniają łatwą w zrozumieniu i wykorzystaniu abstrakcję.
\end_layout

\begin_layout Plain Layout
Distributed list, dictionary, counter
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operacje zbiorcze
\begin_inset CommandInset label
LatexCommand label
name "sub:Koncepcja-Operacje-zbiorcze"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
bo chcemy minimalizować narzuty komunikacyjne - znowu, czy to nie implementacja?
?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zamki rozproszone
\begin_inset CommandInset label
LatexCommand label
name "sub:Koncepcja-Zamki-rozproszone"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
bo potrzebujemy sekcje krytyczne
\end_layout

\end_inset


\end_layout

\begin_layout Section
Logowanie zdarzeń
\end_layout

\begin_layout Standard
jest
\end_layout

\begin_layout Subsection
OpenXES
\end_layout

\begin_layout Standard
nasza implementacja standardu 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ale o implementacji to w implementacji
\end_layout

\end_inset


\end_layout

\begin_layout Standard
process mining
\end_layout

\begin_layout Standard
much image
\end_layout

\begin_layout Standard
Wizualizacja logów
\end_layout

\begin_layout Standard
Disco
\end_layout

\end_body
\end_document
