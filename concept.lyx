#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Koncepcja i projekt systemu
\end_layout

\begin_layout Standard
Proponowany model programowania miał być jak najbardziej naturalny dla programos
tów zaznajomionych z zagadnieniami programowania równoległego i korzystać
 z koncepcji wątków, współdzielonej pamięci, zamków.
 Wprowadzone abstrakcje wysokiego poziomu miały na celu ukrycie przez użytkownik
iem leżącego u podstaw programowania rozproszonego mechnizmu przesyłania
 komunikatów.
 Klaster sysetmu Bluepath zakłada możliwość bezpośredniej komunikacji każdego
 podłączonego do niego komputera z każdym innym poprzez sieć.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Biblioteka zapewnia szkielet/środowisko (framework?) do tworzenia aplikacji
 rozproszonych.
 Ponadto na węzłach mogą działać dodatkowe usługi.
 
\end_layout

\begin_layout Plain Layout
Aplikacja taka musi zostać rozdystrybuowana na węzły w klastrze przez użytkownik
a.--dodałem punkt w implementacji, gdzie można opisać skrypt PowerShellowy
\end_layout

\end_inset


\end_layout

\begin_layout Section
Usługa odnajdywania węzłów
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zbyt specyficznie na twarz - najpierw trzeba opisać, że jest usługa jaki
 jest jej cel a dopiero potem propozycje najprostszej realizacji.
 W ogólności ta usługa mogłaby być mocno powiązana ze storage i oparta na
 DHT.
 [done]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Jednym z podstawowych założeń jest posiadanie przez wszystkie węzły w systemie
 lokalnego obrazu stanu wszystkich innych węzłów w kalstrze.
 Informacje dotyczące stanu poszczególnych węzłów są dostarczane przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usługę odnajdywania węzłów
\end_layout

\end_inset

.
 Usługa ta powinna obsługiwać sytuację rejestracji oraz wyrejestrowania
 się węzłów.
 System z założenia abstrachuje od sposobu realizacji tej usługi (czy będzie
 to system zcentralizowany, czy rozproszony np.
 oparty na algorytmie plotkującym).
 W związku z pełnioną rolą 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usługa odnajdywania węzłów
\end_layout

\end_inset

 jest kluczowym elementem przy implementacji wykrywania awarii węzłów w
 klastrze.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Odkrywanie węzłów w sieci realizowane jest za pomocą usługi Service Discovery,
 która działa na jednym z węzłów.
 Dołączające się węzły muszą znać adres serwera Service Discovery w celu
 zarejestrowania się w usłudze.
 Rejestracja/wyrejestrowanie się węzła powoduje rozesłania powiadomienia
 o tym fakcie do wszystkich pozostałych węzłów w klastrze.
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
chyba nie za bardzo: Usługa ta okresowo monitoruje obciążenie węzłów.
 W przypadku braku odpowiedzi stwierdzana jest awaria węzła i jest on wyrejestro
wywany z klastra.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zarządca połączeń
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
ConnectionManager
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Każdy węzeł powinien przechowywać lokalnie obraz klastra, aby w momencie,
 kiedy zajdzie potrzeba zlecenia zadania jednemu ze 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zdalnych wykonawców
\end_layout

\end_inset

, nie musiał odpytywać usługi katalogowej.
 Tym zadaniem zajmuje się 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zarządca połączeń
\end_layout

\end_inset

.
 Posiada też dodatkowe informacje, które mogą przydać
\begin_inset space \space{}
\end_inset

się 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
planiście
\end_layout

\end_inset

, np.
 obciążenie węzłów.
\end_layout

\begin_layout Section
Rozproszony wątek
\end_layout

\begin_layout Standard
Jednostką przetwarzania w systemie jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
rozproszony wątek
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
nazwa?
\end_layout

\end_inset

.
 Jest on tworzony na podstawie statycznej metody, która przyjmuje dowolną,
 liczbę parametrów i zwraca wartość.
 Wynik przechwytywany jest przez środowisko i udostępniany do odczytu na
 węźle, który zlecił wykonanie wątku.
 Rozproszony wątek może zostać wykonany na dowolnym węźle obliczeniowym
 oraz uruchamiać kolejne rozproszone wątki.
 Decyzja o wyborze miejsca wykonania wątku podejmowana jest z wykorzystaniem
 lokalnej wiedzy o stanie klastra przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
planistę
\end_layout

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
(więcej o tym dalej, bo pisanie o interefejsie i własnym schedulerze to
 chyba nie tu).
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Typy w systemie
\end_layout

\begin_layout Standard
W trakcie projektowania systemu założono, że wszystkie typy przesyłane pomiędzy
 węzłami muszą być serializowalne (posiadać atrybut 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
Serializable
\end_layout

\end_inset

).
\end_layout

\begin_layout Section
Wykonawca
\end_layout

\begin_layout Standard
W celu ograniczenia liczby zadań pełnionych przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszony wątek
\end_layout

\end_inset

 zdefiniowano 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wykonawcę
\end_layout

\end_inset

 - element odpowiedzialny za wykonywanie wątków zarówno zdalne jak i lokalne.
 Zastosowanie takiej abstrakcji pozwala potraktować przetwarzanie lokalne
 oraz zdalne w podobny sposób.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Czy to ma sens?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wykonawca lokalny
\end_layout

\begin_layout Standard
Wszystkie wątki wykonywane lokalnie (zarówno te które pochodzą z lokalnego
 węzła jak i te zlecone przez inny węzeł) są zarządzane przez 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
wykonawców lokalnych
\end_layout

\end_inset

.
 Do zadań 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wykonawcy lokalnego
\end_layout

\end_inset

 należą:
\end_layout

\begin_layout Itemize
rozpoczęcie przetwarzania, 
\end_layout

\begin_layout Itemize
przekierowanie parametrów, 
\end_layout

\begin_layout Itemize
przechwycenie wyjątków,
\end_layout

\begin_layout Itemize
udostępnienie wyników wyższym warstwom po zakończeniu przetwarzania.
\end_layout

\begin_layout Subsection
Wykonawca zdalny
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Coś, że niezbędna jest abstrakcja zdalnego wykonania w celu ładnie poukładanego
 kodu (Single Responsibility Class itp.)
\end_layout

\end_inset

Abstrakcją zdalnego uruchomienia 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
rozproszonego wątku
\end_layout

\end_inset

 jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
wykonawca zdalny
\end_layout

\end_inset

.
 Zleca on wykonanie zadania 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[wyspecyfikowanemu]
\end_layout

\end_inset

węzłowi wybranemu przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
planistę
\end_layout

\end_inset

 oraz monitoruje stan wykonania zadania (zakończenie, wystąpienie błędów).
 Jest on również odpowiedzialny za odebranie wyniku przetwarzania i udostępnieni
e ich wyższym warstwom.
\end_layout

\begin_layout Section
Planista
\end_layout

\begin_layout Standard
Elementem systemu decydującym o wyborze miejsca wykonywania 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
rozproszonego wątku
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
nazwa?
\end_layout

\end_inset

 jest 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
planista
\end_layout

\end_inset

.
 Każda jego realizacja musi być oparta na zdefiniowanym interfejsie.
 Dzięki temu użytkownik może przygotować własną implementację 
\begin_inset Flex Name
status collapsed

\begin_layout Plain Layout
planisty
\end_layout

\end_inset

 dostosowaną do prowadzonego przetwarzania lub wybrać jedną z dostarczonych
 razem z biblioteką.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Musi on implementować interfejs 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
IScheduler
\end_layout

\end_inset

.
 Pozwala to zastosować implementację Planisty dostosowaną do potrzeb przetwarzan
ia i jest jednym z istotnych elementów modułowości sys
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pamięć współdzielona
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:concept-Rozproszona-pamięć-współdzielona"

\end_inset

Często w ramach przetwarzania rozproszonego zachodzi potrzeba komunikacji.
 W celu jej zapewnienia, jako część biblioteki 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Bluepath
\end_layout

\end_inset

, dostarczany jest mechanizm 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Pamięć ta ma charakter pamięci masowej, a nie pamięci operacyjnej.
\begin_inset Note Note
status open

\begin_layout Plain Layout
(?) 
\end_layout

\end_inset

Zastosowanie takiego mechanizmu pozwala ukryć problemy komunikacyjne związane
 z wymianą danych i udostępnić programiście interfejs do którego jest przyzwycza
jony z programowania aplikacji równoległych.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Coś z tym zdaniem przed tą notatką jest nie tak.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W celu identyfikacji danych w pamięci współdzielonej zastosowano klucze.
 Klucz jest unikalnym ciągiem znaków jednoznacznie identyfikującym dane.
 W trakcie projektowania 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 nie przewidziano zapewnienia hierarchii kluczy.
 Tego typu mechanizm, choć przydatny w pewnych przypadkach, może zostać
 dostarczony przez warstwy obudowujące dostęp do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Aby zapewnić wysoką użyteczność, oraz możliwość rozbudowy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 przewidziane zostały następujące operacje:
\end_layout

\begin_layout Itemize
zapis -- operacja zapisująca dane; w przypadku gdy podany klucz już istnieje
 operacja nie powiedzie się,
\end_layout

\begin_layout Itemize
zapis lub aktualizacja -- operacja zapisująca dane; w przypadku gdy podany
 klucz istnieje, wartość zostanie nadpisana,
\end_layout

\begin_layout Itemize
aktualizacja -- operacja aktualizująca dane -- powiedzie się tylko wtedy,
 gdy podany klucz został wcześniej utworzony w pamięci współdzielonej,
\end_layout

\begin_layout Itemize
pobranie -- operacja pobierająca dane -- powiedzie się tylko wtedy gdy podany
 klucz został wcześniej utworzony,
\end_layout

\begin_layout Itemize
usunięcie -- operacja usuwająca dane -- powiedzie się tylko wtedy gdy podany
 klucz został wcześniej utworzony w pamięci współdzielonej.
\end_layout

\begin_layout Standard
Operacje te, choć wystarczające w większości zastosowań, zostały rozwinięte
 o odpowiedniki operujące na wielu kluczach na raz - zostały one opisane
 w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Koncepcja-Operacje-zbiorcze"

\end_inset

.
\end_layout

\begin_layout Standard
Dzięki tak zdefiniowanej semantyce operacji na podstawie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 można równierz zdefiniować bardziej złożone mechanizmy takie jak 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamki rozproszone
\end_layout

\end_inset

.
 Ponieważ część mechanizmów zapewniających realizację 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 może posiadać wbudowane mechanizmy zapewniające 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamki rozproszone
\end_layout

\end_inset

 zdefiniowano 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozszerzoną pamięć współdzieloną
\end_layout

\end_inset

, której operacje zostały opisane w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Koncepcja-Zamki-rozproszone"

\end_inset

.
\end_layout

\begin_layout Subsection
Współdzielone struktury danych i obiekty
\end_layout

\begin_layout Standard
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Pamięć współdzielona
\end_layout

\end_inset

 mimo tego, że zapewnia operacje niezbędne do komunikacji w trakcie przetwarzani
a, może okazać się mechanizmem o zbyt niskim poziomie abstrakcji.
 Efektem mogło by być wielokrotne pisanie przez programistę podobnych fragmentów
 kodu w celu obsługi 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Aby uniknąć takiej sytuacji wprowadzone zostały struktury danych i obiekty
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

trzy podstawowe kolekcj
\begin_inset Quotes erd
\end_inset

 -- licznik to nie do końca kolekcja...
 (ale to Ty, Piotr, pisałeś to zdanie :D)
\end_layout

\end_inset

 oparte na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

: lista, słownik oraz licznik.
\end_layout

\begin_layout Paragraph
Lista rozproszona
\end_layout

\begin_layout Standard
Głównym zadaniem 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
listy rozproszonej
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
czy to jest nazwa?
\end_layout

\end_inset

 jest przechowywanie i udostępnianie listy obiektów dostępnej wszystkim
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonym wątkom
\end_layout

\end_inset

 w systemie, które znają jej identyfikator.
 Dzięki temu użytkownik może zastosować strukturę danych zachowującą się
 w taki sam sposób jak lista dostarczana przez środowisko .NET.
 Podstawowe wykorzystanie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
listy rozproszonej
\end_layout

\end_inset

 nie powinno wymagać wykorzystania dodatkowych mechanizmów takich jak np.
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamki rozproszone
\end_layout

\end_inset

.
\end_layout

\begin_layout Paragraph
Słownik rozproszony
\end_layout

\begin_layout Standard
Ze względu na charakter 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 (zapisywanie wartości pod pewnym konkretnym kluczem) naturalnym wydaje
 się dostarczenie programiście abstrakcji wzorowanej na słowniku (ang.
 dictionary).
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Słownik rozproszony
\end_layout

\end_inset

 pozwoli użytkownikowi na łatwiejsze zarządzanie kolekcjami typu klucz-wartość
 jednocześnie zapewniając poprawność wykonania pewnych operacji (np.
 atomowe dodanie nowego klucza oraz zarejestrowanie go na liście kluczy).
\begin_inset Note Note
status open

\begin_layout Plain Layout
trochę shitowy ten opis :(
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Licznik rozproszony
\end_layout

\begin_layout Standard
Jedną z podstawowych struktur rozproszonych jest 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
licznik rozproszony
\end_layout

\end_inset

.
 Jego główną cechą - oprócz atomowego zapisania wartości liczbowej - jest
 jednoczesne pobranie i zmienienie wartości.
 Pozwala to wykorzystać go jako np.
 generatora kluczy, czy wykorzystać tę strukturę do dynamicznego podziału
 kolekcji na fragmenty (każdy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszony wątek
\end_layout

\end_inset

 pobiera wartość licznika i jednocześnie zwiększa jego wartość o 100 - w
 ten sposób wątek może przetworzyć 100 elementów począwszy od uzyskanej
 wartości mając pewność, że żaden inny wątek nie zacznie przetwarzać tych
 elementów).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zapewniają łatwą w zrozumieniu i wykorzystaniu abstrakcję.
\end_layout

\begin_layout Plain Layout
Distributed list, dictionary, counter
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operacje zbiorcze
\begin_inset CommandInset label
LatexCommand label
name "sub:Koncepcja-Operacje-zbiorcze"

\end_inset


\end_layout

\begin_layout Standard
Głównym kosztem przetwarzania rozproszonego są narzuty komunikacyjne.
 Wykonywanie 1000 rządań w celu pobrania tysiąca elementów z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 jest wysoce nieefektywne.
 W celu ominięcia tego problemu dla każdej operacji na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 zdefiniowano jej odpowiednik przyjmujący jako parametr zbiór kluczy.
 Dodanie tego typu operacji pozwoli użytkownikowi w znaczący sposób zwiększyć
 efektywność swojego przetwarzania (np.
 poprzez jednorazowe pobranie do pamięci lokalnej przetwarzanych danych).
\begin_inset Note Note
status open

\begin_layout Plain Layout
bo chcemy minimalizować narzuty komunikacyjne - znowu, czy to nie implementacja?
? - na razie napiszę - jeśli ustalimy, że jednak implementacja to przeniesiemy
 tekst :)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Zamki rozproszone
\begin_inset CommandInset label
LatexCommand label
name "sub:Koncepcja-Zamki-rozproszone"

\end_inset


\end_layout

\begin_layout Standard
Przetwarzanie rozproszone oparte na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonych wątkach
\end_layout

\end_inset

 podobnie jak przetwarzanie równoległe może wymagać zastosowania sekcji
 krytycznych.
 Operacje na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 zostały zdefiniowane w taki sposób, aby możliwe było stworzenie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamków rozproszonych
\end_layout

\end_inset

 opartych o ten mechanizm.
 W związku z tym tworzenie i zarządzanie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamkami rozproszonymi
\end_layout

\end_inset

 jest częścią obowiązków pamięci współdzielonej.
\end_layout

\begin_layout Standard
Ponieważ reszta infrastruktury nie polega na sposobie implementacji zamków
 (a jedynie na zapewnieniach
\begin_inset Note Note
status open

\begin_layout Plain Layout
nie wiem jak to inaczej nazwać
\end_layout

\end_inset

 jakie oferują) mogą one zostać zaimplementowane w oparciu o mechanizmy
 nie związane z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięcią współdzieloną
\end_layout

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
bo potrzebujemy sekcje krytyczne
\end_layout

\end_inset


\end_layout

\begin_layout Section
Logowanie zdarzeń
\end_layout

\begin_layout Standard
jest
\end_layout

\begin_layout Subsection
OpenXES
\end_layout

\begin_layout Standard
nasza implementacja standardu 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ale o implementacji to w implementacji
\end_layout

\end_inset


\end_layout

\begin_layout Standard
process mining
\end_layout

\begin_layout Standard
much image
\end_layout

\begin_layout Standard
Wizualizacja logów
\end_layout

\begin_layout Standard
Disco
\end_layout

\end_body
\end_document
