#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Podsumowanie
\end_layout

\begin_layout Standard
abc...
\end_layout

\begin_layout Section
Przebieg realizacji
\end_layout

\begin_layout Standard
abc...
\end_layout

\begin_layout Section
Napotkane problemy
\end_layout

\begin_layout Standard
abc...
\end_layout

\begin_layout Subsection
Serializacja
\end_layout

\begin_layout Standard
abc...
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
WYJĄTKI, o jej problemach
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Środowisko do testów integracyjnych.
\end_layout

\begin_layout Standard
abc...
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
był problem żeby bootstrapować
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dystrybucja aplikacji do węzłów
\end_layout

\begin_layout Standard
abc...
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
rozwiązane skryptem w PowerShellu
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
rhino-dht
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "par:problemy-rhino-dht"

\end_inset

abc...
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
nie działało
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Redis uruchamiany w systemie Windows
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "par:problemy-Windows-Redis"

\end_inset

Podczas pracy usługi Redis z dużym obciążeniem pod kontrolą systemu Windows
 zaobserwowano znaczący spadek wydajności.
 Wyjaśnienie problemów z działaniem znaleziono w dokumencie 
\begin_inset CommandInset citation
LatexCommand cite
key "MSOpenTech-Redis-Release-Notes"

\end_inset

.
 
\end_layout

\begin_layout Standard
W wersji dla systemu Linux wszystkie operacje wejścia-wyjścia korzystają
 z deskryptorów plików, które nie są tak rozpowszechnione w API systemu
 Windows.
 Wersja przeznaczona dla systemów Windows używa w związku z tym symulowanego
 deskryptora plików.
 Zasadniczym problemem jest jednak brak obecności wywołania systemowego
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fork
\end_layout

\end_inset

 do tworzenia procesów potomnych, która w systemie Windows została zasymulowana
 poprzez umieszczenie sterty procesu Redis w 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
memory-mapped file
\end_layout

\end_inset

, czyli fragmencie pamięci wirtualnej, która jest dokładnym odwzorowaniem
 pliku znajdującego się na dysku lub -- w ogólności -- obiektu, do którego
 jesteśmy w stanie uzyskać deskryptor.
 Taki deskryptor przekazywany jest następnie potomnym procesom.
 Warto zauważyć, że domyślnym zachowaniem środowiska jest tworzenie współdzielon
ego pliku o rozmiarze odpowiadającym rozmiarowi pamięci fizycznej komputera.
 
\end_layout

\begin_layout Standard
Ostatecznie różnice, które ujawniły się pomiędzy wersją usługi Redis przeznaczon
ą dla systemów Windows a pochodnych UNIXa, wpłynęły na podjęcie decyzji
 o uruchomieniu go w systemie operacyjnym Ubuntu.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Differences from UNIX versions Networking On UNIX all IO operations occur
 with file descriptors regardless of the type of IO operation.
 Most IO mechanisms in Windows do not use file descriptors.
 The approach we have taken is to unify all of Windows IO operations under
 a simulated file descriptor.
 We do not support named pipes at this time with our simulated file descriptor
 code.
 Fork Redis uses the fork() UNIX system API to create a point-in-time snapshot
 of the data store for storage to disk.
 This impacts several features on Redis: AOF/RDB backup, master-slave synchroniz
ation, and clustering.
 Windows does not have a fork-like API available, so we have had to simulate
 this behavior by placing the Redis heap in a memory mapped file that can
 be shared with a child process.
 In order to control the size of this file we have added a maxheap flag.
 See the Redis.Windows.conf file for details on the usage of this flag.
 The default size of this file is equal to the size of physical memory on
 your target machine.
 If there is insufficient disk space for this file Redis will fail to start.
 Dependencies This version of Redis is dependent on the Microsoft Visual
 C++ 2012 Redistributable Package.
 If you are developing in VS2012 you already have what you need.
 You can get the redistributable from Microsoft at http://support.microsoft.com/kb
/2019667 , or you can get this from Chocolately at https://chocolatey.org/package
s/vcredist2012.
 
\end_layout

\begin_layout Plain Layout
[Windows Redis package: Redis Release Notes.docx]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wyładowywanie kodu z pamięci
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:problemy-Wyladowywanie-kodu-z-pamieci"

\end_inset

Klasycznym mechanizmem oddzielania od siebie aplikacji jest stosowanie abstrakcj
i procesu, z których każdy posiada swoją własną przestrzeń adresową.
 Komunikacja między procesami może zachodzić jedynie z użyciem mechanizmów
 udostępnianych przez system operacyjny.
 
\end_layout

\begin_layout Standard
Środowisko .NET Framework wprowadza koncepcję domen aplikacji
\begin_inset Note Note
status open

\begin_layout Plain Layout
??
\end_layout

\end_inset

 (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
application domains
\end_layout

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "MSDN-Applications-Domains"

\end_inset

, która pozwala uruchomić w ramach jednego procesu wiele odizolowanych aplikacji.
 Do zalet tego podejścia należą:
\end_layout

\begin_layout Itemize
brak narzutu związanego z użyciem mechanizmów systemu operacyjnego do wykonywani
a wywołań między procesami,
\end_layout

\begin_layout Itemize
błędy w jednej z aplikacji nie wpłyną na pozostałe,
\end_layout

\begin_layout Itemize
poszczególne aplikacje mogą być wyładowywane z pamięci bez zatrzymywania
 całego procesu.
\end_layout

\begin_layout Standard
Domena aplikacji jest najmniejszą jednostką, jaką można wyładować z pamięci.
 Nie jest to możliwe dla pojedynczych typów czy bibliotek
\begin_inset Note Note
status open

\begin_layout Plain Layout
??
\end_layout

\end_inset

 (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
assembly
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Application Domains -- http://msdn.microsoft.com/en-us/library/2bh4z9hs(v=vs.110).as
px
\end_layout

\begin_layout Plain Layout
Add-ony
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementacja standardu OpenXES
\begin_inset Note Note
status open

\begin_layout Plain Layout
 na
\begin_inset space ~
\end_inset

podstawie pliku XSD
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:problemy-Implementacja-standardu-OpenXES-z-XSD"

\end_inset

Podczas próby implementacji standardu OpenXES opisanej w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:implementation-Logowanie-zdarzen"

\end_inset

 na podstawie plików XML Schema udostępnionych 28 marca 2014 r.
 wraz z wersją 2.0 bibliteki napotkano problemy przy próbie automatycznego
 wygenerowania klas.
 W jednym z plików, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
xes.xsd
\end_layout

\end_inset

, znaleziony został drobny błąd składniowy -- brakująca spacja, co powodowało,
 że plik XML był niepoprawny składniowo i nieprzyjmowany przez narzędzie
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
xsd.exe
\end_layout

\end_inset

.
 Po jego poprawieniu ujawnił się kolejny problem objawiający się wyjątkiem
 przepełnienia stosu w trakcie generowania klas.
 Ten problem został rozwiązany przez objęcie wnętrza elementu 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
xs:complexType
\end_layout

\end_inset

 odnoszącego się do typu 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AttributableType
\end_layout

\end_inset

 elementem 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
xs:sequence
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Perspektywy dalszego rozwoju
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Subsection
Niezawodność przetwarzania
\end_layout

\begin_layout Standard
Aspektem, który nie został poruszony w niniejszej pracy jest zapewnienie
 niezawodności przetwarzania w przypadku awarii węzłów.
 Awarie mogą dotyczyć węzłów danych lub węzłów obliczeniowych.
 
\end_layout

\begin_layout Standard
W przypadku węzłów danych zapewnienie bezpieczeństwa leży po stronie wybranej
 do ich zrealizowania aplikacji.
 System Redis może zostać uruchomiony w trybie z replikacją, w którym jeden
 z węzłów jest punktem dostępowym do zapisu lub odczytu, a jego repliki
 udostępniają dane tylko do odczytu.
 Po awarii węzła nadrzędnego jedna z replik staje się nowym punktem dostępowym
 z możliwością zapisu.
\begin_inset Note Note
status open

\begin_layout Plain Layout
jest jeszcze inna możliwość??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Obsługa awarii węzłów obliczeniowych w przypadku, gdy aplikacja nie posiada
 współdzielonego stanu, czyli nie wykorzystuje współdzielonych struktur
 danych ani obiektów -- a więc wywołania są idempotentne -- mogłaby uwzględniać
 drzewiasty charakter takiego przetwarzania.
 Rozproszone wątki zainicjowane przez stracony węzeł musiałyby być wycofane,
 a węzeł nadrzędny musiałby zlecić jeszcze raz wykonanie przerwanego wątku.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Lepsze implementacje poszczególnych części (i tu można się rozwodzić)
\end_layout

\begin_layout Itemize
niezawodność, obsługa awarii, wycofywawnie drzewa przetwarzania i wznawianie
 wątków (AsResumable?)
\end_layout

\begin_layout Itemize
Więcej rozproszonych struktur danych (kolejka)
\end_layout

\begin_layout Itemize
Pełne wsparcie LINQ 
\end_layout

\begin_deeper
\begin_layout Itemize
(AsResumable)
\end_layout

\end_deeper
\begin_layout Itemize
rozbudowa interfejsu komunikacji z systemem
\end_layout

\begin_deeper
\begin_layout Itemize
ReportProgress
\end_layout

\begin_layout Itemize
LocalStorage
\end_layout

\end_deeper
\begin_layout Itemize
implementacja service discovery jako zdecentralizowanego katalogu (DHT?)
\end_layout

\begin_layout Itemize
wykorzystanie w pełni asynchronicznych wzorców z .NET 4.5 (async, await)
\end_layout

\end_inset


\end_layout

\end_body
\end_document
