#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementacja
\end_layout

\begin_layout Standard
Projekt systemu zakładał napisanie go w języku C# w środowisku .NET Framework
 4.5
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Microsoft.NET"

\end_inset

 i umożliwienie wykonywania kodu użytkownika z bibliotek skompilowanych
 do kodu zarządzalnego pod w .NET Framework w wersji nie nowszej niż 4.5.
 Testy wykonania kodu użytkownika zostały przeprowadzone z użyciem aplikacji
 napisanych w językach C# oraz F#.
 System Bluepath działa na klastrze węzłów obliczeniowych.
 Na każdym węźle musi zostać uruchomiona binarnie zgodna wersja aplikacji,
 w stopniu umożliwiającym wykonanie dowolnej metody z dowolnej klasy będącej
 częścią procesu za pomocą zserializowanego uchwytu otrzymanego w ramach
 zlecenia (pod pewnymi warunkami opisanymi w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:implementation-Rozproszony-watek"

\end_inset

).
 W ramach jednego z wątków uruchamiana jest usługa nasłuchująca na wywołania
 -- zlecenia, zapytania -- przychodzące od pozostałych węzłów.
\end_layout

\begin_layout Section
Komunikacja
\end_layout

\begin_layout Standard
Komunikacja między węzłami została zrezlizowana w modelu RPC (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
remote procedure call
\end_layout

\end_inset

) za pomocą Windows Communication Foundation 
\begin_inset CommandInset citation
LatexCommand cite
key "MSDN:WhatIsWindowsCommunicationFoundation"

\end_inset

.
 Połączenia realizowane są za pomocą protokołu HTTP, a wiadomości są przesyłane
 zgodnie z protokołem SOAP 
\begin_inset CommandInset citation
LatexCommand cite
key "Poznaj-SOAP"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: przydałoby się przechwycić
\begin_inset space \space{}
\end_inset

Wiresharkiem jakąś kopertę, może taką z uchwytem do metody?
\end_layout

\end_inset

.
 Firewall blokujący połączenia przychodzące na portach o wysokich numerach
 lub NAT uniemożliwią poprawne działanie systemu.
 Wątek nasłuchujący jest reprezentowany przez obiekt klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BluepathListener
\end_layout

\end_inset

.
 Wewnętrznie tworzy on instancję klasy faktycznie nasłuchującej na losowym
 porcie na wiadomości zgodne z interfejsem 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
IRemoteExecutorService
\end_layout

\end_inset

, który został przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:implementation-Interfejs-IRemoteExecutorService"

\end_inset

.
 Dokonywana jest też rejestracja w 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usłudze odnajdywania węzłów
\end_layout

\end_inset

.
 Jeżeli w ramach jednego procesu zostanie utworzone kilka instancji klasy
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BluepathListener
\end_layout

\end_inset

 każda z nich będzie nasłuchiwała na innym porcie i posiadała własną kolekcję
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
lokalnych wykonawców
\end_layout

\end_inset

.
 Lista znanych 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zdalnych wykonawców
\end_layout

\end_inset

 jest współdzielona w ramach procesu przez wszystkie wątki nasłuchujące.
 
\end_layout

\begin_layout Standard
W systemie każdy węzeł może komunikować się z dowolnym innym, o ile zna
 jego adres IP i numer portu, pod którym działa usługa.
 Komunikaty, zarówno wywołania (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
request
\end_layout

\end_inset

) jak i wywołania zwrotne (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
callback
\end_layout

\end_inset

), mają charakter asynchroniczny.
 Istnieje również możliwość wyłączenia wywołań zwrotnych i przełączenia
 systemu w tryb pracy z odpytywaniem (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
polling
\end_layout

\end_inset

).
 Wydaje się, że nie ma to sensu w przypadku prowadzenia w klastrze faktycznych
 obliczeń, gdyż wprowadza dodatkowe opóźnienia, ale przydaje się w niektórych
 scenariuszach realizowanych środowisku testowym.
\begin_inset Note Note
status open

\begin_layout Plain Layout
To 'ale przydaje się'...
 brzmi trochę lamersko - może trzeba wymyślić przypadek kiedy może być użyteczne
 - np.
 callbacki często giną, więc lepiej overhead i polling - przynajmniej nie
 zawiśniemy [a co w pollingu jak wyślemy zapytanie o status, ale nie dostaniemy
 odpowiedzi[mimo że doszło], a następnie wyślemy takie samo zapytanie jeszcze
 raz?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zastosowane protokoły nie zapewniają żadnych gwarancji co do kolejności
 dostarczonych wiadomości.
 Nie zapewniają również niezawodności dostarczania wiadomości ponad to,
 co oferuje protokół działający w warstwie transportowej -- TCP.
 Zakładamy jednak, że połączenia w obrębie jednego klastra są na tyle stabilne,
 że nie będzie to powodowało problemów.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
+??? WCF, HTTP, SOAP
\end_layout

\begin_layout Plain Layout
-można przekonfigurować na coś innego
\end_layout

\begin_layout Plain Layout
+bluepathlistener - tworzy serwis hosta, który implementuje 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
IRemoteExecutorService
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
+Jeżeli w ramach procesu działa więcej niż 1 listener każdy ma swój port
 i swoją kolekcję lokalnych wykonawców, ale współdzielą listę zdalnych wykonawcó
w.
 
\end_layout

\begin_layout Plain Layout
+Callbacki (wywołania zwrotne) vs.
 pooling
\end_layout

\begin_layout Plain Layout
+pod spodem jest to właściwie tradycyjny model RPC, ale abstrakcja rozproszonych
 wątków ukrywa to przed użytkownikiem.
\end_layout

\begin_layout Plain Layout
+komunikacja z użyciem asynchronicznych wiadomości
\end_layout

\begin_layout Plain Layout
+kolejność wiadomości - dowolna
\end_layout

\begin_layout Plain Layout
+niezawodność dostarczania - jeżeli protokół TCP zgubi wiadomość, mamy problem
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Interfejs IRemoteExecutorService
\begin_inset CommandInset label
LatexCommand label
name "lis:implementation-Interfejs-IRemoteExecutorService"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

[ServiceContract]
\end_layout

\begin_layout Plain Layout

public interface IRemoteExecutorService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Guid Initialize(byte[] methodHandle);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Execute(Guid eId, object[] parameters, ServiceUri callbackUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void ExecuteCallback(Guid eid, RemoteExecutorServiceResult executeResult);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    RemoteExecutorServiceResult TryJoin(Guid eId);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    PerformanceStatistics GetPerformanceStatistics();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Usługa odnajdywania węzłów
\end_layout

\begin_layout Standard
Obecna implementacja zawiera usługę odnajdywania węzłów zrealizowaną w sposób
 scentralizowany, a każdy z węzłów podłączających się do klastra musi znać
 adres IP i numer portu, pod którym działa usługa katalogowa.
 Usługa udostępnia metody służące do zarejestrowania się węzła (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Register
\end_layout

\end_inset

), wyrejestrowania się węzła (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Unregister
\end_layout

\end_inset

), pobrania listy zarejestrowanych w klastrze węzłów (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetAvailableServices
\end_layout

\end_inset

), oraz pobrania statystyk wydajności wszystkich węzłów w klastrze (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetPerformanceStatistics
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Interfejs ICentralizedDiscoveryService
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

[ServiceContract]
\end_layout

\begin_layout Plain Layout

public interface ICentralizedDiscoveryService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    ServiceUri[] GetAvailableServices();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Register(ServiceUri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Unregister(ServiceUri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Task<Dictionary<ServiceUri, PerformanceStatistics>> GetPerformanceStatistics
();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Rozproszona pamięć współdzielona
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
nie implementujemy sami bo nie taki cel pracy
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zgodnie z założeniami zaprezentowanymi w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:concept-Rozproszona-pamięć-współdzielona"

\end_inset

, interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IStorage
\end_layout

\end_inset

 wymaga implementacji metod do operacji na pojedynczych wartościach: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Store
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
StoreOrUpdate
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Update
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Retrieve
\end_layout

\end_inset

 i 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Remove
\end_layout

\end_inset

 oraz operacji zbiorczych: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BulkStore
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BulkStoreOrUpdate
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BulkUpdate
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BulkRetrieve
\end_layout

\end_inset

 i 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BulkRemove
\end_layout

\end_inset

.
 Dodatkowo zdefiniowany został interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IExtendedStorage
\end_layout

\end_inset

 rozszerzający podstawowy interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IStorage
\end_layout

\end_inset

 o operacje pobrania i zwolnienia 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonych zamków
\end_layout

\end_inset

: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AcquireLock
\end_layout

\end_inset

 (w wersji z limitem czasu i bez) oraz 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ReleaseLock
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Rozważane rozwiązania 
\end_layout

\begin_layout Standard
Podjęto decyzje o skorzystaniu z jednego z istniejących rozwiązań do zrealizowan
ia koncepcji 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
współdzielonej pamięci
\end_layout

\end_inset

.
 Pod uwagę brane były następujące aplikacje:
\end_layout

\begin_layout Itemize
Memcached -- niestety projekt był aktualizowany ostatni raz w roku 2013
 a jego implementacja opiera się o .NET Framework 2.0,
\end_layout

\begin_layout Itemize
Riak -- który jest implementacją Amazon Dynamo 
\begin_inset CommandInset citation
LatexCommand cite
key "Amazon-Dynamo"

\end_inset

, odrzucony ze względu na brak API dla .NET Framework,
\end_layout

\begin_layout Itemize
Polyphony -- eksperymentalny projekt rozproszonej tablicy haszowej napisany
 w języku F#, nie wybrano ze względu na wczesnorozwojowy charakter projektu,
\end_layout

\begin_layout Itemize
Rhino DHT -- implementacja rozproszonej tablicy haszowej w języku C#; posiada
 zależności do Rhino PHT (
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
persistent hash table
\end_layout

\end_inset

) oraz Rhino Queues.
\end_layout

\begin_layout Standard
Początkowo wybrane zostało rozwiązanie Rhino DHT
\begin_inset Note Note
status open

\begin_layout Plain Layout
throw new NotImplementedException(); https://github.com/ayende/rhino-dht
\end_layout

\end_inset

, które było aktywnie rozwijane przez rozpoznawalnego autora -- Ayende Rahiena.
 Niestety, okazało się, że wersjonowanie danych nie zostało w pełni zaimplemento
wane i nie było możliwe wykonanie atomowej 
\begin_inset Note Note
status open

\begin_layout Plain Layout
warunkowej? test?
\end_layout

\end_inset

operacji ,,odczytaj i zapisz'', która była niezbędna do zrealizowania 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamków
\end_layout

\end_inset

.
 Szczegóły tego problemu zostały przedstawione punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:problemy-rhino-dht"

\end_inset

.
 
\end_layout

\begin_layout Standard
Kolejnym rozwiązaniem wziętym pod uwagę był Redis.
 Jest to otwarto-źródłowy system przechowujący dane typu klucz-wartość autorstwa
 Salvatore Sanfilippo oraz Pieter'a Noordhuis.
 Jest używany na co dzień jako mechanizm pamięci podręcznej wielu serwisów
 internetowych (m.in.
 cała rodzina StackExchange) - posiada przez to duże wsparcie i aktywnie
 działającą społeczność.
 Redis potrafi działać zarówno jako pojedynczy proces jak i w trybie master-slav
e, ponadto rozwijana jest wersja rozproszona -- Redis Cluster.
 System ten posiada biblitekę dla .NET Framework dostarczoną przez firmę
 StackExchange.
 Redis został napisany dla rodziny systemów operacyjnych linux, powstał
 jednak port tego systemu do systemu operacyjnego Windows.
 Problemy, które napotkano podczas uruchamiania usługi Redis (opisane w
 punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:problemy-Windows-Redis"

\end_inset

) udało się obejść, przez co system ten został wykorzystany w ostatecznej
 wersji pracy i w testach.
\end_layout

\begin_layout Subsection
Współdzielone struktury danych i obiekty
\end_layout

\begin_layout Standard
Struktury danych i obiekty, które mogą być współdzielone między wątkami
 zaimplementowane zostały w oparciu o 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięć współdzieloną
\end_layout

\end_inset

, zdefiniowaną za pomocą interfejsu 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IExtendedStorage
\end_layout

\end_inset

 - pozwoliło to zastosować 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zamki rozproszone
\end_layout

\end_inset

 w celu zapewnienia poprawności przetwarzania.
 Każdy obiekt jest identyfikowany przez klucz będący łańcuchem znaków.
 W przypadku listy czy słownika na podstawie klucza wywiedzione zostają
 identyfikatory obiektów składających się na daną strukturę -- zamków, metadanyc
h i poszczególnych wartości.
 
\end_layout

\begin_layout Paragraph
Lista
\end_layout

\begin_layout Standard
Lista implementuje standardowy generyczny interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IList<T>
\end_layout

\end_inset

 z przestrzeni nazw 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Collections.Generic
\end_layout

\end_inset

.
 Próba pobrania enumeratora zwraca obiekt klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedListEnumerator
\end_layout

\end_inset

, który umożliwia iterowanie po kolekcji.
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Lista rozproszona
\end_layout

\end_inset

 została rozszerzona o operację 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CopyPartTo
\end_layout

\end_inset

 - jest to odpowiednik operacji 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CopyTo
\end_layout

\end_inset

 (efektywnej operacji kopiowania całej zawartości listy do wskazanej tablicy),
 który pozwala skopiować wybrany fragment listy w sposób efektywny i atomowy.
 Operacja ta jest szczególnie przydatna przy przetwarzaniu rozproszonym,
 gdzie dane znajdują się w wolnej 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

 (w stosunku do pamięci podręcznej), a każdy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątek rozproszony
\end_layout

\end_inset

 przetwarza fragment danych.
\end_layout

\begin_layout Paragraph
Słownik
\end_layout

\begin_layout Standard
Słownik implementuje standardowy generyczny interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IDictionary<TKey, TValue>
\end_layout

\end_inset

 z przestrzeni nazw 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Collections.Generic
\end_layout

\end_inset

.
 Próba pobrania enumeratora zwraca obiekt klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedDictionaryEnumerator
\end_layout

\end_inset

, który umożliwia iterowanie po kolekcji.
 
\end_layout

\begin_layout Paragraph
Licznik
\end_layout

\begin_layout Standard
W wielu scenariuszach (przykładowy scenariusz opisany w 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:koncepcja-distributed-counter"

\end_inset

) przydatnym obiektem może być współdzielony licznik.
 Zaimplementowana klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedCounter
\end_layout

\end_inset

 udostępnia następujące operacje: 
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetValue
\end_layout

\end_inset

 -- pobiera aktualną wartość licznika,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SetValue
\end_layout

\end_inset

 -- ustawia podaną liczbę jako wartość licznika,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Increase
\end_layout

\end_inset

 -- zwiększa wartość licznika o podaną wartość,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Decrease
\end_layout

\end_inset

 -- zmniejsza wartość licznika o podaną wartość,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetAndIncrease
\end_layout

\end_inset

 -- atomowo pobiera aktualną wartość licznika i zwiększa ją o wskazaną liczbę,
 gdzie liczba o którą ma zostać zwiększony licznik może być ujemna.
\end_layout

\begin_layout Section
Rozproszony wątek
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:implementation-Rozproszony-watek"

\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedThread
\end_layout

\end_inset

 to klasa, której instancje reprezentują jednostkę przetwarzania w systemie.
 Wątek taki tworzony jest na podstawie delegatu 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Func
\end_layout

\end_inset

 opakowującego statyczną (nazwaną lub anonimową) metodę.
 Liczba parametrów wejściowych takiej metody to maksymalnie 16.
 Wszystkie typy parametrów oraz typ zwracany muszą być oznaczone atrybutem
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Serializable
\end_layout

\end_inset

.
 Środowisko zakłada izolację pomiędzy wątkami: wątki działające w ramach
 jednego procesu--hosta nie mogą komunikować się ze sobą poprzez pamięć
 operacyjną, a parametry, z którymi wywoływana jest metoda są kopiowane
 do nowych instancji klas i struktur.
 Wyjątkiem jest tutaj dostarczana przez środowisko pamięć współdzielona.
 W tym przypadku programista powinien stosować dostarczone wraz z nią mechanizmy
 synchronizacji.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Czy użycie własnych typów może wymagać dodatnia adnotacji KnownType do DataContr
act? http://msdn.microsoft.com/en-us/library/ms730167(v=vs.110).aspx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zapis do pamięci współdzielonej jest thread-safe? Jeżeli tak, można o tym
 napisać.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Koperta SOAP -- inicjalizacja zdalnego wykonawcy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
\end_layout

\begin_layout Plain Layout
	<s:Body>
\end_layout

\begin_layout Plain Layout
		<Initialize xmlns="http://tempuri.org/">
\end_layout

\begin_layout Plain Layout
			<methodHandle>AAEAAAD/////AQAAAAAAAAAMAgAAAD9
[...]
\lang polish
==</methodHandle>
\end_layout

\begin_layout Plain Layout
		</Initialize>
\end_layout

\begin_layout Plain Layout
	</s:Body>
\end_layout

\begin_layout Plain Layout
</s:Envelope>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Wykonawca
\end_layout

\begin_layout Standard
Każdy wykonawca jest identyfikowany przez unikalną 128-bitową liczbę (GUID),
 przy czym instancja 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zdalnego wykonawcy
\end_layout

\end_inset

 używa takiego samego identyfikatora jak 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
lokalny wykonawca
\end_layout

\end_inset

, który został zainicjowany do wykonania kodu użytkownika.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://blogs.msdn.com/b/oldnewthing/archive/2008/06/27/8659071.aspx
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
ThreadPool - zhejtować można (ale trochę) - nie można przerywać zadań.
 Sprawdzanie stanu wątków.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lokalny wykonawca szereguje wątki do wykonania używając dostarczonej przez
 środowisko .NET Framework puli wątków (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ThreadPool
\end_layout

\end_inset

).
 Podejście to ma swoje wady -- tracona jest kontrola nad tak stworzonymi
 wątkami, nie można ich przerwać lub sprawdzić ich stanu (uniemożliwia to
 np.
 realizację detekcji zakleszczenia).
 W przypadku, gdy w kodzie użytkownika wystąpi wyjątek, zostanie on przechwycony
 przez środowisko, zserializowany i udostępniony wywołującemu wątkowi do
 odczytu.
\end_layout

\begin_layout Section
Planista
\end_layout

\begin_layout Standard
Wraz z systemem dostarczone zostały następujące typy planistów:
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ThreadNumberScheduler
\end_layout

\end_inset

 -- szereguje zadania na najmniej obciążonym węźle pod względem liczby wykonywan
ych na nim wątków,
\end_layout

\begin_layout Itemize
i na razie nie ma innych.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO! round-robin?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Poniżej opisane zostały szczegółowo ich implementacje.
 Testy porównawcze i analiza wyników zaprezentowane zostały w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:performance-Porownanie-planistow"

\end_inset

.
\end_layout

\begin_layout Subsection
Szeregowanie zadań
\begin_inset Note Note
status open

\begin_layout Plain Layout
mocne stwierdzenie ;)
\end_layout

\end_inset

 w oparciu o obciążenie węzłów
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:implementacja-szeregowanie-zadan-threadcount"

\end_inset

Jednym z podstawowych sposobów szeregowania zadań jest próba równomiernego
 rozłożenia obciążenia węzłów.
 Zakładając, że wszystkie zadania mają podobny rozmiar, jako miarę obciążenia
 konkretnego węzła można przyjąć liczbę zadań, które są obecnie przetwarzane,
 lub oczekują na rozpoczęcie przetwarzania.
\end_layout

\begin_layout Standard
W przykładowej implementacji dostarczanej wraz z biblioteką 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Bluepath
\end_layout

\end_inset

 informacje o obecnym obciążeniu węzłów są okresowo odświerzane prz pomocy
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usługi odnajdywania węzłów
\end_layout

\end_inset

.
 W zależności od szybkości tworzenia nowych 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątków rozproszonych
\end_layout

\end_inset

 oraz częstotliwości odświerzania informacji o obciążeniu węzłów lokalne
 dane mogą szybko stać się przeterminowane.
 Można ten efekt złagodzić poprzez zwiększanie zapamiętanego obciążenia
 o wysłane na dany węzeł wątki.
\end_layout

\begin_layout Subsection
Szeregowanie zadań za pomocą algorytmu karuzelowego
\end_layout

\begin_layout Standard
W pewnych zastosowaniach pewne zrównowarzenie obciążenia można osiągnąć
 poprzez zastosowanie algorytmu karuzelowego (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
round robin
\end_layout

\end_inset

)
\begin_inset Note Note
status open

\begin_layout Plain Layout
O! Tannenbaum!
\end_layout

\end_inset

.
 Algorytm ten nie wymaga pobierania informacji o obciążeniu węzłów z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
usługi odnajdywania węzłów
\end_layout

\end_inset

 przez co posiada mniejszy narzut komunikacyjny od algorytmów wymagających
 tych informacji.
 W sytuacji gdy tylko jeden węzeł tworzy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątki rozproszone
\end_layout

\end_inset

 efekt działania algorytmu karuzelowego będzie identyczny z efektem osiągniętym
 przez zastosowanie algorytmu opisanego w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:implementacja-szeregowanie-zadan-threadcount"

\end_inset

.
\end_layout

\begin_layout Section
Logowanie zdarzeń
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:implementation-Logowanie-zdarzen"

\end_inset

Za zbieranie informacji na temat zdarzeń zachodzących w systemie odpowiada
 klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Log
\end_layout

\end_inset

 udostępniająca statyczne metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ExceptionMessage
\end_layout

\end_inset

 -- do logowania wyjątków i 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TraceMessage
\end_layout

\end_inset

 -- do logowania pozostałych zdarzeń.
 Istnieje możliwość przekierowania wszystkich informacji do współdzielonej
 pamięci.
\begin_inset Note Note
status open

\begin_layout Plain Layout
jest zahardcodowany new RedisStorage!! (??)
\end_layout

\end_inset

 W tym celu należy ustawić flagę 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
WriteToRedis
\end_layout

\end_inset

 oraz uzupełnić nazwę hosta współdzielonej pamięci (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RedisHost
\end_layout

\end_inset

), do którego ma odbywać się zapis.
 Warto zwrócić uwagę, że tryb pracy ze zbieraniem historii zdarzeń we współdziel
onej pamięci może istotnie ograniczać wydajność systemu.
 W celu zmaterializowania zebranego logu udostępniona została metoda 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SaveXes
\end_layout

\end_inset

, która zapisuje wszystkie zgromadzone we współdzielonej pamięci zdarzenia
 do pliku XML w formacie OpenXES.
 
\end_layout

\begin_layout Standard
Implementacja standardu została wykonana na podstawie zmodyfikowanych plików
 XML Schema (XSD) udostępnionych wraz z biblioteką OpenXES 2.0 (przyczyny
 i sposób modyfikacji został opisany w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:problemy-Implementacja-standardu-OpenXES-z-XSD"

\end_inset

).
 Szkielet klas został wygenerowany przy użyciu narzędzia 
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
XML Schema Definition Tool
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "XML-Schema-Definition-Tool"

\end_inset

 (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
xsd.exe
\end_layout

\end_inset

) dostarczanego wraz ze środowiskiem programistycznym .NET Framework 4.5.1.
 Przykład użycia narzędzia xsd.exe został zaprezentowany na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:implementation-Skrypt-generujący-klasy-z-XSD"

\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "s"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "breaklines=true,language=bash"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:implementation-Skrypt-generujący-klasy-z-XSD"

\end_inset

Skrypt generujący klasy w języku C# na podstawie pliku XSD dla formatu OpenXES
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

"c:
\backslash
Program Files (x86)
\backslash
Microsoft SDKs
\backslash
Windows
\backslash
v8.1A
\backslash
bin
\backslash
NETFX 4.5.1 Tools
\backslash
xsd.exe" xes.xsd /classes /o:../Bluepath/Reporting/ 
\end_layout

\begin_layout Plain Layout

"c:
\backslash
Program Files (x86)
\backslash
Microsoft SDKs
\backslash
Windows
\backslash
v8.1A
\backslash
bin
\backslash
NETFX 4.5.1 Tools
\backslash
xsd.exe" xesext.xsd /classes /o:../Bluepath/Reporting/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zdarzenie jest wynikiem zarejestrowania 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
aktywności
\end_layout

\end_inset

 (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
activity
\end_layout

\end_inset

).
 Rodzaje aktywności zachodzących w systemie zostały zdefiniowane w formie
 typu wyliczeniowego 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Bluepath.Reporting.Log.Activity
\end_layout

\end_inset

.
 Przykładowe z nich to: 
\end_layout

\begin_layout Itemize
zgłoszenie przez węzeł gotowości do przyjęcia zleceń (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Service_is_ready
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
rozpoczęcie wykonywania kodu użytkownika w ramach rozproszonego wątku (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Local_executor_started_running_user_code
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
zakończenie wykonywania kodu użytkownika na węźle (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Local_executor_finished_running_user_code
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
wysłanie wywołania zwrotnego z wynikiem działania wątku (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Sending_callback_with_result
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Wszystkie zdarzenia, które są mało istotne dla analizy procesu mogą być
 grupowane w ramach aktywności 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Info
\end_layout

\end_inset

 i powinny zostać odfiltrowane w pierwszej fazie analizy.
 Jeżeli użytkownik chce użyć własnej nazwy dla zdarzenia, może to zrobić
 korzystając z aktywności 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Custom
\end_layout

\end_inset

, a właściwą nazwę przekazać jako parametr 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
message
\end_layout

\end_inset

 do metody logowania zdarzeń.
 
\end_layout

\begin_layout Standard
Jako 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
zasób
\end_layout

\end_inset

 (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
resource
\end_layout

\end_inset

) wskazywany jest zawsze wykonawca, który dokonał wpisu, korzystając z jego
 unikalnego identyfikatora 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
eid
\end_layout

\end_inset

.
 Implementacja zakłada możliwość skrócenia zapisu do n ostatnich znaków
 składających się na identyfikator w celu ułatwienia analizy przez człowieka.
 Może to potencjalnie wpłynąć na fałszywe sklasyfikowanie różnych zasobów
 jako tego samego w wyniku kolizji tak skonstruowanych identyfikatorów.
\end_layout

\begin_layout Standard
Zależności czasowe są istotną częścią analizy przebiegu procesu.
 Z wykorzystaniem serwerów czasu NTP możliwe jest zsynchronizowanie zegarów
 węzłów w klastrze z dokładnością do ??
\begin_inset Note Note
status open

\begin_layout Plain Layout
hm, no właśnie??
\end_layout

\end_inset

.
 Aby zachować porządek zdarzeń w miejsce na milisekundy wpisywana jest wartość
 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
współdzielonego licznika
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
chyba nie do końca jest to dobre, bo jak jeden węzeł jest jeszcze w poprzedniej
 sekundzie a drugi już w bieżącej to mamy problem ;)
\end_layout

\begin_layout Plain Layout
jakiś art.
 o process mining basics: http://www.wiso.uni-hamburg.de/fileadmin/wiso_fs_wi/Publi
kationen/Michael/Gehrke_und_Werner_-_2013_-_Process_Mining_Pre-print_Version.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Section
Interfejs do komunikacji z systemem
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[Communication framework] Shared storage access,
\end_layout

\begin_layout Plain Layout
Udostępnianie logu (bo jest statyczny)
\end_layout

\begin_layout Plain Layout
potencjalnie mogłoby być reporting
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aby skorzystać z funkcji udostępnianych przez system (jak np.
 pobranie identyfikatora 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wykonawcy
\end_layout

\end_inset

 czy dostęp do wspóldzielonej rozproszonej pamięci) wewnątrz rozproszonego
 wątku, użytkownik musi uzyskać przeznaczony do tego obiekt.
 System automatycznie wstrzykuje go do metod jako jeden z parametrów --
 wystarczy, by był on typu interfejsu 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IBluepathCommunicationFramework
\end_layout

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Nie po polsku jest to
\end_layout

\end_inset


\end_layout

\begin_layout Section
Dystrybucja aplikacji w klastrze
\end_layout

\begin_layout Standard
PowerShell Remoting to usługa umożliwiająca wykonanie na zdalnych maszynach
 pojedynczych komend lub stworzenie pełnej zdalnej sesji PowerShell.
 Automatyzacja procesu dystrybucji plików binarnych systemu w klastrze została
 zrealizowana za pomocą zestawu skryptów: 
\begin_inset Flex Path
status open

\begin_layout Plain Layout
Send-Folder
\end_layout

\end_inset

 do przesyłania całych folderów i 
\begin_inset Flex Path
status open

\begin_layout Plain Layout
Send-File
\end_layout

\end_inset

 do przesyłania pojedynczych plików, z którego korzysta ten pierwszy.
 
\end_layout

\begin_layout Standard
Skrypt do wysyłania pojedynczych plików został zaczerpnięty z książki 
\begin_inset CommandInset citation
LatexCommand cite
key "Windows-PowerShell-Cookbook"

\end_inset

.
 Przyjmuje 3 parametry: ścieżkę do pliku źródłowy znajdującego się na lokalnej
 maszynie, ścieżkę docelową na zdalnej maszynie oraz referencję do obiektu
 zdalnej sesji.
 Plik jest wczytywany do pamięci jako tablica bajtów, następnie jego transfer
 odbywa się strumieniowo w blokach o rozmiarze 1 MB.
 Po zrekonstruowaniu tablicy bajtów na zdalnej stronie jest ona zapisywana
 na dysk we wskazanej lokalizacji.
\end_layout

\begin_layout Standard
Skrypt do wysyłania folderów przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:implementation-Send-Folder"

\end_inset

 przyjmuje jako parametry: adres zdalnego komputera (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-server
\end_layout

\end_inset

), opcjonalnie port, na którym nasłuchuje usługa PowerShell Remoting (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-port
\end_layout

\end_inset

), nazwę użytkownika (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-user
\end_layout

\end_inset

), hasło (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-password
\end_layout

\end_inset

), ścieżkę do folderu źródłowego na lokalnej maszynie (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-source
\end_layout

\end_inset

), ścieżkę do folderu docelowego na zdalnej maszynie (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-destination
\end_layout

\end_inset

).
 Skrypt tworzy obiekt zdalnej sesji uwierzytelniając się poprzez podaną
 nazwę użytkownika i hasło.
 W celu uproszczenia etapu konfiguracji środowiska, do wywołania metody
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
New-PSSession
\end_layout

\end_inset

 można dodać przełącznik 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-SessionOption (New-PSSessionOption -SkipCACheck)
\end_layout

\end_inset

.
 Opcja ta powoduje jednak zmniejszenie bezpieczeństwa poprzez dopuszczenie
 niezaufanych certyfikatów maszyn.
 Następnie pobierana jest lista plików we wskazanym lokalnym folderze i
 dla każdego z plików wywoływany skrypt 
\begin_inset Flex Path
status open

\begin_layout Plain Layout
Send-File
\end_layout

\end_inset

.
 Pomijane przy tym są pliki z symbolami (
\begin_inset Flex Path
status open

\begin_layout Plain Layout
.pdb
\end_layout

\end_inset

), ponieważ ich rozmiar jest znaczący w stosunku do rozmiaru plików samej
 aplikacji, a nie było konieczne podłączanie 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
debuggera
\end_layout

\end_inset

 do procesów pracujących na zdalnych maszynach.
 Po zakończeniu przesyłania plików zdalna sesja jest zamykana.
 Warto zauważyć, że skrypt 
\begin_inset Flex Path
status open

\begin_layout Plain Layout
Send-Folder
\end_layout

\end_inset

 można wywołać w pętli, aby przesłać pliki do każdego komputera w klastrze.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:implementation-Send-Folder"

\end_inset

Skrypt przesyłający pliki ze wskazanego folderu na zdalną maszynę
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

param (
\end_layout

\begin_layout Plain Layout

	[string]$server = $(throw "-server is required."),
\end_layout

\begin_layout Plain Layout

	[int]$port = 5986,
\end_layout

\begin_layout Plain Layout

	[string]$user = $(throw "-user is required."),
\end_layout

\begin_layout Plain Layout

	[string]$password = $(throw "-password is required."),
\end_layout

\begin_layout Plain Layout

	[string]$source = $(throw "-source is required."),
\end_layout

\begin_layout Plain Layout

	[string]$destination = $(throw "-destination is required.")
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$secPassword = ConvertTo-SecureString $password -AsPlainText -Force
\end_layout

\begin_layout Plain Layout

$credential = New-Object System.Management.Automation.PSCredential($user, $secPassw
ord)
\end_layout

\begin_layout Plain Layout

$uri = New-Object System.Uri("https://" + $server + ":" + $port)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$session = New-PSSession -ConnectionUri $uri -Credential $credential
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Get-ChildItem -Path $source -File | Foreach-Object {
\end_layout

\begin_layout Plain Layout

	if ($_.Extension -ne ".pdb") {
\end_layout

\begin_layout Plain Layout

		$target = $destination + $_.Name
\end_layout

\begin_layout Plain Layout

		.
\backslash
Send-File.ps1 $_.FullName $target $session
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Disconnect-PSSession $session
\end_layout

\end_inset


\end_layout

\end_body
\end_document
