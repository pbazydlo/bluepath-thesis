
\chapter{PrzykÅ‚adowe zastosowania}

\label{chap:applications}W tym rozdziale przedstawione zostanÄ… przykladowe
zastosowania systemu Bluepath. Na bazie \dcsname{wÄ…tkÃ³w rozproszonych},
\dcsname{pamiÄ™ci rozproszonej} i nadbudowanych nad niÄ… abstrakcji
listy i sÅ‚ownika przygotowane zostaÅ‚y projekty:
\begin{itemize}
\item \dcsstrong{DLINQ} (ang.~\dcsemph{Distributed Language Integrated Query})
-- dostawca metod manipulacji kolekcji w sposÃ³b zgodny z obecnym juÅ¼
w Å›rodowisku .NET dla standardowych, nierozproszonych kolekcji, 
\item \dcsstrong{MapReduce} -- abstrakcja specjalizowana do uruchamiania
zadaÅ„ w modelu mapowania i redukcji z moÅ¼liwoÅ›ciÄ… zlecania zadaÅ„ bez
koniecznoÅ›ci ponownej kompilacji systemu i dystrybuowania nowej wersji
plikÃ³w wykonywalnych na wÄ™zÅ‚y,
\item \dcsstrong{System uzupeÅ‚niania wyrazÃ³w} -- system przygotowujÄ…cy
na podstawie podanej kolekcji dokumentÃ³w bazÄ™ prefiksÃ³w, ktÃ³ra jest
wykorzystywana do realizacji systemu podpowiedzi sÅ‚Ã³w na podstawie
pierwszych liter wpisywanych przez uÅ¼ytkownika,
\item \dcsstrong{Obliczanie przybliÅ¼enia liczby $\pi$} -- algorytm obliczajÄ…cy
przybliÅ¼onÄ… wartoÅ›Ä‡ liczby $\pi$, ktÃ³ry umoÅ¼liwiÅ‚ przeprowadzenie
testÃ³w porÃ³wnawczych szybkoÅ›ci obliczeÅ„ w klastrze bez wykorzystania
\dcsname{pamiÄ™ci rozproszonej} w stosunku do obliczeÅ„ prowadzonych
na pojedynczym wÄ™Åºle.
\end{itemize}

\section{DLINQ}

Jednym z przykÅ‚adowych zastosowaÅ„ biblioteki Bluepath jest Distributed
Language Integrated Query (DLINQ) -- zbiÃ³r metod roszerzajÄ…cych moÅ¼liwoÅ›ci
operowania na kolekcjach bazowanych na \dcsname{pamiÄ™ci rozproszonej}.
Obecna implementacja sÅ‚uÅ¼y jako przykÅ‚ad (ang.~\dcsemph{proof of concept})
wykorzystania moÅ¼liwoÅ›ci dostarczanych przez bibliotekÄ™ Bluepath i
dlatego dostarcza implementacjÄ™ podzbioru metod standardowego zestawu
LINQ:
\begin{itemize}
\item \dcscode{Select} -- operacja ta pozwala przetransformowaÄ‡ obiekt,
np. wybierajÄ…c jedynie podzbiÃ³r jego atrybutÃ³w, lub zmieniajÄ…c typ
obiektu,
\item \dcscode{SelectMany} -- operacja podobna do \dcscode{Select} z tÄ…
rÃ³Å¼nicÄ…, Å¼e pojedynczy obiekt w wyniku transformacji zmieniany jest
w kolekcjÄ™ obiektÃ³w, a powstaÅ‚e w ten sposÃ³b kolekcje sÄ… Å‚Ä…czone w
jednÄ…,
\item \dcscode{Where} -- operacja ta pozwala wyfiltrowaÄ‡ te obiekty, ktÃ³re
speÅ‚niajÄ… podany warunek,
\item \dcscode{GroupBy} -- operacja pozwalajÄ…ca grupowaÄ‡ obiekty wedÅ‚ug
zadanego klucza,
\item \dcscode{Count} -- operacja zliczajÄ…ce obiekty speÅ‚niajÄ…ce zadany
warunek. 
\end{itemize}
Operacje te mogÄ… byÄ‡ wykonywane zarÃ³wno na dostarczonej z bibliotekÄ…
Bluepath liÅ›cie rozproszonej (opisanej w \ref{sub:----Koncepcja-wspoldzielone-struktury-danych})
jak i na wszystkich obiektach implementujÄ…cych interfejs \dcscode{IEnumerable}.
W drugim przypadku kolekcja ÅºrÃ³dÅ‚owa zostanie najpierw przetransformowana
do listy rozproszonej, a nastÄ™pnie poddana dalszemu przetwarzaniu.

SposÃ³b wykorzystania rozszerzeÅ„ DLINQ jest wzorowany na Parallel Language
Integrated Query (PLINQ). Aby poddaÄ‡ kolekcjÄ™ przetwarzaniu rozproszonemu
wykonujemy najpierw metodÄ™ rozszerzajÄ…cÄ… \dcscode{AsDistributed}.
Metoda ta posiada jeden obowiÄ…zkowy argument -- obiekt zapewniajÄ…cy
dostÄ™p do \dcsname{pamiÄ™ci rozproszonej}. NastÄ™pnie na otrzymanym
z tej metody obiekcie moÅ¼na wykonywaÄ‡ operacje zdefiniowane w DLINQ.
NaleÅ¼y jednak mieÄ‡ na uwadze, Å¼e operacje te podlegajÄ… zaÅ‚oÅ¼eniom
biblioteki Bluepath i funkcje podawane jako argumenty muszÄ… byÄ‡ funkcjami
statycznymi. Na listingu \ref{lis:Transformacja-kolekcji-DLINQ} przedstawiono
przykÅ‚adowy kod poddajÄ…cy kolekcjÄ™ transformacji przy uÅ¼yciu metody
\dcscode{Select}.

\inputencoding{latin2}\begin{lstlisting}[caption={Transformacja kolekcji przypomocy
metod dostarczonych w DLINQ},label={lis:Transformacja-kolekcji-DLINQ},breaklines=true,language={[Sharp]C},numbers=left]
var inputCollection = new List<double>(100);
...
var processedCollection = (from num in inputCollection.AsDistributed(storage) select Math.Sqrt(num)).ToList();
\end{lstlisting}
\inputencoding{utf8}

W implementacji DLINQ moÅ¼na wyrÃ³Å¼niÄ‡ 3 podstawowe klasy: \dcscode{DistributedQuery},
\dcscode{DistributedEnumerable} oraz \dcscode{UnaryQueryOperator}.
ZostaÅ‚y one dokÅ‚adniej opisane w poniÅ¼szych punktach.


\subsection{DistributedQuery}

W celu zapewnienia jednoznacznego rozrÃ³Å¼nienia pomiÄ™dzy metodami LINQ,
oraz DLINQ wprowadzono klasÄ™ \dcscode{DistributedQuery}. Klasa ta
czÄ™Å›ciowo implementuje interfejs \dcscode{IEnumerable} zapewniajÄ…c
powiÄ…zania pomiÄ™dzy metodami tego interfejsu. Stanowi ona bazÄ™ z ktÃ³rej
wywodzÄ… siÄ™ wszystkie klasy realizujÄ…ce poszczegÃ³lne wywoÅ‚ania DLINQ
(np. \dcscode{Select}) co pozwala na wykonywanie tych samych metod
na instancjach rÃ³Å¼nych klas skÅ‚adowych DLINQ.


\subsection{DistributedEnumerable}

Statyczna klasa \dcscode{DistributedEnumerable} zawiera wszystkie
metody rozszerzajÄ…ce DLINQ. KaÅ¼da z tych metod weryfikuje parametry
wejÅ›ciowe w celu przekazania uÅ¼ytkownikowi zrozumiaÅ‚ych informacji
w przypadku podania bÅ‚Ä™dnych parametrÃ³w. NastÄ™pnie tworzona jest klasa
realizujÄ…ca wywoÅ‚anie DLINQ i zwracana uÅ¼ytkownikowi w celu dalszego
przetwarzania (samo wykonanie podobnie jak w LINQ nastÄ™puje dopiero
wtedy gdy potrzebne sÄ… wyniki np. wywoÅ‚anie metody \dcscode{ToList},
lub enumeracja).

SpecjalnÄ… metodÄ… rozszerzajÄ…cÄ… zaimplementowanÄ… w klasie \dcscode{DistributedEnumerable}
jest metoda \dcscode{AsDistributed}. SÅ‚uÅ¼y ona przygotowaniu kolekcji
wejÅ›ciowej do przetwarzania przez metody DLINQ. Jest to realizowane
poprzez opakowanie kolekcji wejÅ›ciowej klasÄ… \dcscode{DistributedEnumerableWrapper},
ktÃ³ra przenosi zawartoÅ›Ä‡ kolekcji wejÅ›ciowej do \dcsname{listy rozproszonej}
(wyjÄ…tkiem jest sytuacja, w ktÃ³rej kolekcja wejÅ›ciowa jest \dcsname{listÄ… rozproszonÄ…}).


\subsection{UnaryQueryOperator}

KlasÄ… bazowÄ… dla klas implementujÄ…cych metody DLINQ jest \dcscode{UnaryQueryOperator}.
Jest to klasa, ktÃ³ra gromadzi wszystkie metody wspÃ³lne dla metod DLINQ
takich jak tworzenie \dcsname{wÄ…tkÃ³w rozproszonych} z wykorzystaniem
ustawieÅ„ przekazanych przez uÅ¼ytkownika w metodzie \dcscode{AsDistributed},
czy zebranie wynikÃ³w przetwarzania z poszczegÃ³lnych \dcsname{wÄ…tkÃ³w rozproszonych}.
Nazwa \dcscode{UnaryQueryOperator} wynika z faktu, Å¼e wszystkie metody
DLINQ oparte na tej klasie operujÄ… na jednej kolekcji. W przypadku
implementacji metod takich jak \dcscode{Union} -- metoda odpowiadajÄ…ca
za poÅ‚Ä…czenie dwÃ³ch kolekcji -- naleÅ¼aÅ‚oby stworzyÄ‡ kolejne klasy,
np. \dcscode{BinaryQueryOperator}.


\section{MapReduce}

\label{sec:applications-MapReduce}W celu porÃ³wnania pracochÅ‚onnoÅ›ci
implementacji aplikacji z uÅ¼yciem bibliteki Bluepath i bez niej przygotowane
zostaÅ‚y aplikacje do realizacji przetwarzania w modelu mapowania i
redukcji zarÃ³wno w Å›rodowisku Bluepath jak i bezpoÅ›rednio z~wykorzystaniem
platformy Windows Communication Foundation~\cite{MSDN:WhatIsWindowsCommunicationFoundation}.
ZaÅ‚oÅ¼eniem aplikacji byÅ‚o, by kod metod \dcscode{Map} i \dcscode{Reduce}
dostarczany byÅ‚ jako kod ÅºrÃ³dÅ‚owy w jÄ™zyku C\# w formie klasy implementujÄ…cej
odpowiedni interfejs -- \dcscode{IMapProvider} lub \dcscode{IReduceProvider}
-- przedstawiony na listingu \ref{lis:applications-MapReduce-IMapProvider-IReduceProvider}
i skÅ‚adowany razem z danymi w~\dcsname{pamiÄ™ci rozproszonej}. Kompilacja
kodu miaÅ‚a odbywaÄ‡ siÄ™ na wÄ™zÅ‚ach bezpoÅ›rednio przed wykonaniem metody,
do zrealizowania tego celu wybrana zostaÅ‚a biblioteka CS-Script~\cite{CS-Script}. 

\noindent %
\begin{minipage}[t]{1\textwidth}%
\inputencoding{latin2}\begin{lstlisting}[caption={Interfejsy
IMapProvider i IReduceProvider},label={lis:applications-MapReduce-IMapProvider-IReduceProvider},breaklines=true,language={[Sharp]C},numbers=left]
public interface IMapProvider 
{
   IEnumerable<KeyValuePair<string, string>> Map(string key, string value); 
}

public interface IReduceProvider 
{
   KeyValuePair<string, string> Reduce(string key, IEnumerable<string> values); 
}
\end{lstlisting}
\inputencoding{utf8}%
\end{minipage}


\subsection{Koordynator}

GÅ‚Ã³wnÄ… klasÄ… w aplikacji jest \dcsname{koordynator}, ktÃ³ry peÅ‚ni
rolÄ™ nadzorcy zadaÅ„ (z tego powodu nazywany jest takÅ¼e \dcsemph{JobTrackerem}).
Jego zadaniem jest przydzielanie zdaÅ„ mapowania i redukcji podlegÅ‚ym
wÄ™zÅ‚om. PoniÅ¼ej opisano jego implementacje z wykorzystaniem biblioteki
Bluepath jak i w oparciu bezpoÅ›rednio o technologiÄ™ WCF.


\subsubsection*{Koordynator oparty o Bluepath}

W Å›rodowisku Bluepath jego zadanie sprowadzaÅ‚o siÄ™ w pierwszej fazie
przetwarzania do uruchomienia \dcsname{wÄ…tkÃ³w rozproszonych} w
liczbie odpowiadajÄ…cej liczbe plikÃ³w wejÅ›ciowych, ktÃ³re byÅ‚y inicjowane
metodÄ…, ktÃ³ra:
\begin{itemize}
\item Å‚adowaÅ‚a kod metody \dcscode{Map} z \dcsname{pamiÄ™ci rozproszonej}, 
\item wykonywaÅ‚a skompilowany kod \dcsemph{mappera} na wskazanym fragmencie
danych wejÅ›ciowych z \dcsname{pamiÄ™ci rozproszonej},
\item zapisywaÅ‚a wygenerowane pary klucz-wartoÅ›Ä‡ do \dcsname{pamiÄ™ci rozproszonej},
\item zwracaÅ‚a listÄ™ kluczy jako wynik wykonania \dcsname{wÄ…tku rozproszonego}
do \dcsname{koordynatora}.
\end{itemize}
Zainicjowane w ten sposÃ³b wÄ…tki byÅ‚y nastÄ™pnie uruchamiane z parÄ…
parametrÃ³w -- nazwÄ… pliku zawierajÄ…cego dane do przetworzenia oraz
nazwÄ… pliku z kodem ÅºrÃ³dÅ‚owym metody \dcscode{Map}. W drugiej fazie
przetwarzania tworzonych byÅ‚o tyle rozproszonych wÄ…tkÃ³w, ile kluczy
byÅ‚o wynikiem pierwszej fazy. KaÅ¼dy z nich inicjowany byÅ‚ metodÄ…,
ktÃ³ra:
\begin{itemize}
\item Å‚adowaÅ‚a kod metody \dcscode{Reduce} z \dcsname{pamiÄ™ci rozproszonej},
\item wykonywaÅ‚a skompilowany kod \dcsemph{reducera} na wskazanym fragmencie
danych wejÅ›ciowych z \dcsname{pamiÄ™ci rozproszonej},
\item zapisywaÅ‚a wygenerowane pary klucz-wartoÅ›Ä‡ do \dcsname{pamiÄ™ci rozproszonej},
\item zwracaÅ‚a listÄ™ kluczy jako wynik wykonania rozproszonego wÄ…tku do
\dcsname{koordynatora}.
\end{itemize}
Przygotowywana jest lista przydziaÅ‚u kluczy do przetwarzania poszczegÃ³lnym
wÄ…tkom dokonujÄ…cym redukcji, po czym sÄ… one uruchamiane z parÄ… parametrÃ³w
-- kluczem oraz nazwÄ… pliku z kodem ÅºrÃ³dÅ‚owym metody \dcscode{Reduce}.


\subsubsection*{Koordynator w technologii WCF}

W projekcie bez uÅ¼ycia biblioteki Bluepath koordynator jest opisany
za pomocÄ… interfejsu definiujÄ…cego kontrakt usÅ‚ugi (\dcscode{ServiceContract})
i udostÄ™pnia koÅ„cÃ³wkÄ™ WCF (ang.~\dcsemph{WCF endpoint}). Interfejs
ten zostaÅ‚ przedstawiony na listingu \ref{lis:applications-MapReduce-ICoordinatorService}.
W tej implementacji koordynator, oprÃ³cz zlecania wykonania zadaÅ„,
musi rÃ³wnieÅ¼ zajÄ…Ä‡ siÄ™ innymi zadaniami zwiÄ…zanymi z obsÅ‚ugÄ… klastra:
\begin{itemize}
\item rejestrowywaniem i wyrejestrowywaniem wÄ™zÅ‚Ã³w, udostÄ™pnianiem ich listy
(metody \dcscode{AddWorker}, \dcscode{RemoveWorker}, \dcscode{GetWorkers}),
\item udostÄ™pnianiem wynikÃ³w przetwarzania, zarÃ³wno peÅ‚nych jak i czÄ™Å›ciowych,
jeÅ¼eli przetwarzanie jeszcze trwa (\dcscode{GetResults}),
\item udostÄ™pnianiem interfejsu do manipulacji danymi znajdujÄ…cymi siÄ™ w
jego czÄ™Å›ci pamiÄ™ci -- zapisywanie, usuwanie, pobieranie listy plikÃ³w,
czyszczenie pamiÄ™ci (\dcscode{AddToStorage}, \dcscode{RemoveFromStorage},
\dcscode{ListStorageFiles}, \dcscode{CleanStorage}).
\end{itemize}
Pliki, ktÃ³re majÄ… byÄ‡ przetwarzane oraz kod metod Map i Reduce muszÄ…
w pierwszej kolejnoÅ›ci trafiÄ‡ do pamiÄ™ci koordynatora. PoszczegÃ³lne
pliki sÄ… nastÄ™pnie wysyÅ‚ane do konkretnych wÄ™zÅ‚Ã³w, ktÃ³rym przydzielone
zostaÅ‚o zadanie ich przetwarzania. Podobnie po zakoÅ„czeniu fazy mapowania
koordynator przygotowuje plan wykonania fazy redukcji i rozsyÅ‚a w
klastrze listÄ™ przydziaÅ‚u kluczy do wÄ™zÅ‚Ã³w. Na tej podstawie wÄ™zÅ‚y
mogÄ… przesÅ‚aÄ‡ miÄ™dzy sobÄ… wyniki poÅ›rednie. Po zakoÅ„czeniu przetwarzania
wÄ™zÅ‚y przesyÅ‚ajÄ… pliki wynikowe do pamiÄ™ci koordynatora.

\inputencoding{latin2}\begin{lstlisting}[caption={Interfejs ICoordinatorService},label={lis:applications-MapReduce-ICoordinatorService},breaklines=true,language={[Sharp]C},numbers=left]
[ServiceContract]
public interface ICoordinatorService
{
    [OperationContract]
    void AddWorker(Uri uri);

    [OperationContract]
    Uri[] GetWorkers();

    [OperationContract]
    void RemoveWorker(Uri uri);

    [OperationContract]
    bool RunJob(int numberOfMappers, int numberOfReducers, Uri mapCodeFile, Uri reduceCodeFile, Uri[] filesToProcess);

    [OperationContract]
    Uri AddToStorage(string fileName, string content);

    [OperationContract]
    Uri[] ListStorageFiles();

    [OperationContract]
    void RemoveFromStorage(Uri uri);

    [OperationContract]
    void CleanStorage();

    [OperationContract]
    MapReduceResult GetResults();
}

[DataContract]
public class MapReduceResult
{
    [DataMember]
    public Tuple<string, string>[] KeysAndValues { get; set; }

    [DataMember]
    public bool IsRunning { get; set; }
}
\end{lstlisting}
\inputencoding{utf8}


\subsection{PamiÄ™Ä‡ masowa}

Aplikacja ta korzysta z abstrakcji pamiÄ™ci masowej, ktÃ³rÄ… definiuje
interfejs \dcscode{IMapReduceStorage}. ZostaÅ‚ on zaprezentowany na
listingu \ref{lis:applications-MapReduce-IMapReduceStorage}. UdostÄ™pnia
on dodatkowe operacje, ktÃ³re umoÅ¼liwiajÄ… np. pobieranie listy istniejÄ…cych
plikÃ³w czy listy kluczy wygenerowanych w wyniku fazy mapowania. Interfejs
ten jest wspÃ³lny dla implementacji z uÅ¼yciem Å›rodowiska Bluepath --
wynikiem jest klasa \dcscode{BluepathStorage} wykorzystujÄ…ca \dcsname{pamiÄ™Ä‡ rozproszonÄ…}
-- jak i bez niego -- w tym przypadku jest to \dcscode{FileSystemStorage}
bazujÄ…cy na systemie plikÃ³w. Klasa \dcscode{FileSystemStorage} przed
zapisaniem pliku na dysk zamienia jego nazwÄ™ na reprezentacjÄ™ w kodowaniu
\dcsstrong{Base64}. MogÅ‚o wiÄ™c siÄ™ zdarzyÄ‡, Å¼e w naziwe pliku pojawi
siÄ™ symbol ,,+''. Po zapisaniu tak zakodowanego klucza za pomocÄ… klasy
\dcscode{System.Uri} nastÄ™powaÅ‚a zamiana znaku ,,+'' na spacjÄ™, przez
co wartoÅ›Ä‡ przestawaÅ‚a byÄ‡ poprawnym ciÄ…giem zgodnym z~kodowaniem
Base64. Jako rozwiÄ…zanie tego problemu zastosowano zamianÄ™ spacji
z~powrotem na znaki ,,+'' w momencie odczytu klucza z otrzymanego
\dcscode{Uri}.

\inputencoding{latin2}\begin{lstlisting}[caption={Interfejs IMapReduceStorage},label={lis:applications-MapReduce-IMapReduceStorage},breaklines=true,language={[Sharp]C},numbers=left]
public interface IMapReduceStorage
{
    IEnumerable<Uri> ListFiles();
    string Read(string fileName);
    string Read(Uri uri);
    string[] ReadLines(string fileName);
    void Store(string fileName, string value);
    void Store(Uri uri, string value);
    void Clean();
    string GetFileName(Uri uri);
    IEnumerable<string> GetKeys();
    void Remove(Uri uri);
}
\end{lstlisting}
\inputencoding{utf8}


\subsection{WÄ™zeÅ‚ obliczeniowy w technologii WCF}

UsÅ‚uga wÄ™zÅ‚a obliczeniowego jest komponentem obecnym jedynie w wersji
aplikacji zbudowanej w oparciu o technologiÄ™ WCF (Å›rodowisko Bluepath
zapewnia moÅ¼lwioÅ›Ä‡ uruchamiania procesÃ³w roboczych na wÄ™zÅ‚ach bez
dodatkowego nakÅ‚adu pracy ze strony programisty). UsÅ‚uga ta zarzÄ…dza
procesami roboczymi na danym wÄ™Åºle oraz peÅ‚ni rolÄ™ poÅ›rednika miÄ™dzy
koordynatorem a procesami roboczymi. WÄ™zÅ‚y mogÄ… komunikowaÄ‡ siÄ™ miÄ™dzy
sobÄ… w celu bezpoÅ›redniego przesÅ‚ania plikÃ³w pomiÄ™dzy fazami mapowania
i redukcji. Interfejs usÅ‚ugi umoÅ¼liwia:
\begin{itemize}
\item utworzenie nowego procesu roboczego (metoda \dcscode{Init}),
\item uruchomienie przetwarzania w ramach jednego z procesÃ³w roboczych (\dcscode{Map},
\dcscode{Reduce}),
\item sprawdzenie, czy przetwarzanie w danym procesie roboczym siÄ™ zakoÅ„czyÅ‚o
(\dcscode{TryJoin}),
\item zlecenie przesÅ‚ania plikÃ³w miÄ™dzy wÄ™zÅ‚ami roboczymi na podstawie listy
przydziaÅ‚u kluczy do wÄ™zÅ‚Ã³w (\dcscode{TransferFiles}),
\item zapisanie pliku w pamiÄ™ci procesu roboczego (\dcscode{PushFile}),
\item pobranie informacji o obciÄ…Å¼eniu wÄ™zÅ‚a (\dcscode{GetPerformanceStatistics})
-- zajÄ™toÅ›ci pamiÄ™ci operacyjnej, obciÄ…Å¼eniu procesora, iloÅ›ci wolnego
miejsca na dysku.
\end{itemize}
\inputencoding{latin2}\begin{lstlisting}[caption={Interfejs
IRemoteWorkerService},label={lis:applications-MapReduce-IRemoteWorkerService},breaklines=true,language={[Sharp]C},numbers=left]
[ServiceContract]
public interface IRemoteWorkerService
{
    [OperationContract]
    void Init(int workerId);

    [OperationContract]
    void Map(Uri uri, Uri mapFuncUri);

    [OperationContract]
    void Reduce(Uri uri, Uri reduceFuncUri);

    [OperationContract]
    string[] TryJoin(int workerId, Uri callbackUri);

    [OperationContract]
    Uri[] TransferFiles(int workerId, Dictionary<string, Uri> keysAndUris);

    [OperationContract]
    Uri PushFile(int workerId, string fileName, string content);

    [OperationContract]
    PerformanceMonitor.PerformanceStatistics GetPerformanceStatistics();

    Uri EndpointUri { get; }
}
\end{lstlisting}
\inputencoding{utf8}


\subsection{Wyniki eksperymentu}

Implementacja Å›rodowiska do przetwarzania w modelu mapowania i redukcji
zajÄ™Å‚a 6~dni dwÃ³m programistom, natomiast z wykorzystaniem biblioteki
Bluepath czas ten skrÃ³ciÅ‚ siÄ™ do 2~dni i to przy zaangaÅ¼owaniu tylko
jednego programisty, a liczba linii kodu zostaÅ‚a zredukowana z 585
do 194.


\section{System uzupeÅ‚niania wyrazÃ³w}

Wiele aplikacji operujÄ…cych na duÅ¼ej iloÅ›ci danych prÃ³buje wspomÃ³c
swoich uÅ¼ytkownikÃ³w pozwalajÄ…c filtrowaÄ‡ dane przy pomocy zapytaÅ„
tekstowych. PoniewaÅ¼ formuÅ‚owanie zapytaÅ„ podlega czÄ™sto ograniczeniom,
np. koniecznoÅ›ci uÅ¼ycia konkretnych sÅ‚Ã³w kluczowych, moÅ¼na stosowaÄ‡
techniki wspomagajÄ…ce uÅ¼ytkownika w~tym dziaÅ‚aniu. 

JednÄ… z takich technik jest system uzupeÅ‚niania wyrazÃ³w (ang.~\dcsemph{autocomplete}).
W trakcie wpisywania zapytania uÅ¼ytkownikowi prezentowana jest lista
zawierajÄ…ca sugerowane zakoÅ„czenia wpisywanego wyrazu. W przypadku
gdy wyraz, ktÃ³ry uÅ¼ytkownik miaÅ‚ zamiar wpisaÄ‡, znajduje siÄ™ na liÅ›cie
moÅ¼e on zostaÄ‡ wybrany. W~przeciwnym wpadku uÅ¼ytkownik musi kontynuowaÄ‡
wpisywanie wyrazu.

System tego typu moÅ¼na zrealizowaÄ‡ poprzez porÃ³wnanie wprowadzonego
sÅ‚owa ze sÅ‚owami wystÄ™pujÄ…cymi w przetwarzanych danych. PoniewaÅ¼ przetwarzanie
wszystkich posiadanych danych w czasie rzeczywistym byÅ‚oby bardzo
powolne, moÅ¼na je poddaÄ‡ wstÄ™pnej obrÃ³bce~--~np. wygenerowaniu i
powiÄ…zaniu prefiksÃ³w z ich moÅ¼liwymi rozwiniÄ™ciami.

System uzupeÅ‚niania wyrazÃ³w zostaÅ‚ zaimplementowany jako przykÅ‚ad
zastosowania biblioteki \dcsname{Bluepath}. Przetwarzanie zostaÅ‚o
podzielone na trzy odrÄ™bne czÄ™Å›ci:
\begin{itemize}
\item wczytywanie danych~--~wytworzenie i powiÄ…zanie prefiksÃ³w i ich rozwiniÄ™Ä‡
-- opisane w \ref{sub:zastosowania-autocomplete-Wczytywanie-danych},
\item uzupeÅ‚nianie wyrazÃ³w~--~demonstracja realizacji funkcji podpowiadania
moÅ¼liwych zakoÅ„czeÅ„ prefiksu -- opisane w \ref{sub:zastosowania-autocomplete-Uzupe=000142nianie-wyraz=0000F3w},
\item czyszczenie stanu systemu~--~przywrÃ³cenie caÅ‚ego systemu do stanu
poczÄ…tkowego bez koniecznoÅ›ci ponownego uruchamiania aplikacji.
\end{itemize}
Na podziaÅ‚ ten miaÅ‚y wpÅ‚yw dwa czynniki:
\begin{itemize}
\item z zaÅ‚oÅ¼enia przygotowywanie prefiksÃ³w (wraz z rozwiniÄ™ciami) miaÅ‚o
byÄ‡ czynnoÅ›ciÄ… niezaleÅ¼nÄ… od wyszukiwania moÅ¼liwych rozwiniÄ™Ä‡ wpisanego
wyrazu~--~system udziela odpowiedzi na podstawie najÅ›wieÅ¼szych posiadanych
danych,
\item w trakcie pisania systemu okazaÅ‚o siÄ™, Å¼e przydatna jest metoda przywracajÄ…ca
system do stanu poczÄ…tkowego, a niebÄ™dÄ…ca czÄ™Å›ciÄ… gÅ‚Ã³wnego przetwarzania.
\end{itemize}

\subsection{Wczytywanie danych}

\label{sub:zastosowania-autocomplete-Wczytywanie-danych}Zaimplementowany
system uzupeÅ‚niania wyrazÃ³w, przed rozpoczÄ™ciem wyszukiwania moÅ¼liwych
zakoÅ„czeÅ„ zadanego prefiksu, musi zostaÄ‡ zainicjalizowany. Dokumenty
zawierajÄ…ce przykÅ‚adowe sÅ‚owa sÄ… wczytywane przez wÄ™zeÅ‚ inicjalizujÄ…cy
operacjÄ™ wczytywania danych i dodawane jako elementy \dcsname{listy rozproszonej}.
NastÄ™pnie kaÅ¼dy \dcsname{wÄ…tek rozproszony} pobiera nieprzetworzony
fragment listy i na podstawie zawartych w nim dokumentÃ³w uzupeÅ‚nia
sÅ‚ownik prefiksÃ³w i moÅ¼liwych dla nich uzupeÅ‚nieÅ„. Gdy na liÅ›cie nie
ma juÅ¼ elementÃ³w do przetworzenia, \dcsname{wÄ…tek rozproszony} koÅ„czy
przetwarzanie. Gdy wszystkie \dcsname{wÄ…tki rozproszone} zakoÅ„czÄ…
przetwarzanie, kaÅ¼dy z wÄ™zÅ‚Ã³w zawiera czÄ™Å›ciowÄ… informacjÄ™ dotyczÄ…cÄ…
prefiksÃ³w i ich uzupeÅ‚nieÅ„. Fragment funkcji \dcscode{LoadDocuments}
odpowiedzialnej za operacjÄ™ wczytywania danych wykonywanÄ… przez \dcsname{wÄ…tek rozproszony}
zostaÅ‚ przedstawiony na listingu \ref{lis:Fragment-funkcji-LoadDocuments}.

\inputencoding{latin2}\begin{lstlisting}[caption={Fragment funkcji LoadDocuments},label={lis:Fragment-funkcji-LoadDocuments},breaklines=true,language={[Sharp]C},numbers=left]
private static int LoadDocuments(string inputKey, string counterKey, int chunkSize, IBluepathCommunicationFramework bluepath)        
{
	var inputList = new DistributedList<string>(bluepath.Storage as IExtendedStorage, inputKey);
	var inputCount = inputList.Count;
	var counter = new DistributedCounter(bluepath.Storage as IExtendedStorage, counterKey);
	int indexEnd = 0;
	do
	{
		int noOfElements = chunkSize; 
		int indexStart = counter.GetAndIncrease(chunkSize); 
		[...]
		var inputDocuments = new string[noOfElements];    
		inputList.CopyPartTo(indexStart, noOfElements, inputDocuments); 
		foreach (var document in inputDocuments)     
		{               
			var words = document.Split(' ');    
			foreach (var word in words)   
			{                     
				[...] // wygenerowanie prefiksów i zapisanie ich w pamiêci lokalnej                  
			}                 
		}
	} while (indexEnd <= inputCount);

	return 0;     
}
\end{lstlisting}
\inputencoding{utf8}


\subsection{UzupeÅ‚nianie wyrazÃ³w\label{sub:zastosowania-autocomplete-Uzupe=000142nianie-wyraz=0000F3w}}

GÅ‚Ã³wnym celem systemu uzupeÅ‚niania wyrazÃ³w jest wyszukiwania moÅ¼liwych
zakoÅ„czeÅ„ zadanego prefiksu. W tym celu naleÅ¼y przeszukaÄ‡ informacje
posiadane przez kaÅ¼dy z wÄ™zÅ‚Ã³w, a nastÄ™pnie zagregowaÄ‡ uzyskane wyniki
czÄ™Å›ciowe. Aby mieÄ‡ pewnoÅ›Ä‡, Å¼e kaÅ¼dy wÄ™zeÅ‚ zostanie przeszukany zastosowano
planistÄ™ szeregujÄ…cego zadania za pomocÄ… algorytmu karuzelowego (opisanego
w punkcie \ref{sub:Implementacja-Szeregowanie-karuzelowy}) i uruchomiono
tyle \dcsname{wÄ…tkÃ³w rozproszonych}, ile znajduje siÄ™ wÄ™zÅ‚Ã³w w
systemie. Inicjalizacja planisty zostaÅ‚a przedstawiona na listingu
\ref{lis:zastosowania-autocomplete-Inicjalizacja-planisty-szereguj=000105}.
\inputencoding{latin2}\begin{lstlisting}[caption={Inicjalizacja
planisty szereguj±cego zadania za pomoc± algorytmu karuzelowego},label={lis:zastosowania-autocomplete-Inicjalizacja-planisty-szereguj=000105},breaklines=true,language={[Sharp]C},numbers=left]
var services = connectionManager.RemoteServices.Select(s => s.Key).ToArray();
var scheduler = new RoundRobinLocalScheduler(services);
\end{lstlisting}
\inputencoding{utf8}

Po zakoÅ„czeniu przetwarzania przez wszystkie wÄ…tki naleÅ¼y zagregowaÄ‡
dane. CzÄ™Å›ciÄ… tej operacji, oprÃ³cz poÅ‚Ä…czenia wynikÃ³w, jest usuniÄ™cie
duplikatÃ³w, ktÃ³re mogÄ… siÄ™ pojawiÄ‡ ze wzglÄ™du na to, Å¼e w tej implementacji
kaÅ¼dy \dcsname{wÄ…tek rozproszony} wykonuje przetwarzanie lokalnie
(niezaleÅ¼nie od pozostaÅ‚ych wÄ…tkÃ³w). Na listingu \ref{lis:zastosowania-autocomplete-Zebranie-wynik=0000F3w-w}
przedstawiono zbieranie wynikÃ³w oraz usuniÄ™cie duplikatÃ³w.\inputencoding{latin2}
\begin{lstlisting}[caption={Zebranie
wyników w systemie uzupe³niania wyrazów},label={lis:zastosowania-autocomplete-Zebranie-wynik=0000F3w-w},breaklines=true,language={[Sharp]C},numbers=left]
var joinedResult = new List<string>();
foreach (var thread in threads)
{
	thread.Join();
	joinedResult.AddRange(thread.Result as string[]);
}

var endResult = joinedResult.Distinct().ToArray();
\end{lstlisting}
\inputencoding{utf8}


\section{Obliczanie przybliÅ¼enia liczby $\pi$}

\label{sec:Przykladowe-zastosowania-liczba-pi}Metoda Monte Carlo
jest formÄ… symulacji z wykorzystaniem generatora liczb pseudolosowych.
KaÅ¼de kolejne uruchomienie algorytmu daje nieco inne wyniki, o ile
nie zapewnimy generatorowi takich samych warunkÃ³w poczÄ…tkowych (ang.~\dcsemph{seed}).
Obliczenie przybliÅ¼enia liczby $\pi$ sprowadza siÄ™ do losowania $n$
razy pary liczb $(x,\thinspace y)$ z~przedziaÅ‚u $[0,\thinspace1]$
i inkrementowaniu licznika $m$, gdy para speÅ‚nia warunek $x^{2}+y^{2}\leq1$.
W przykÅ‚adowej symulacji dla $n=1000000$ otrzymano $m=785930$. Oznacza
to, Å¼e $m$ z $n$ sprawdzonych punkÃ³w znalazÅ‚o siÄ™ w obszarze reprezentujÄ…cym
$\frac{1}{4}$ powierzchni koÅ‚a, ktÃ³rego Å›rodek znajduje siÄ™ w punkcie
(0, 0) -- patrz rysunek \ref{fig:applications-Monte-Carlo-Pi}. Ostateczne
wyliczenie otrzymanego przybliÅ¼enia liczby $\pi$ przedstawia rÃ³wnanie
\ref{eq:applications-Monte-Carlo-Pi}. 
\begin{equation}
p=\frac{m}{n}=\frac{785930}{1000000},\thinspace\thinspace\thinspace p\times4=3,14372\approx\pi\label{eq:applications-Monte-Carlo-Pi}
\end{equation}


\begin{center}
\begin{figure}
\centering{}\includegraphics[scale=0.4]{images/monte-carlo-pi}\protect\caption{\label{fig:applications-Monte-Carlo-Pi}Ilustracja obliczania przybliÅ¼enia
liczby $\pi$ metodÄ… Monte Carlo}
\end{figure}

\par\end{center}

ZwiÄ™kszanie liczby prÃ³bek $n$ nie musi poprawiaÄ‡ dokÅ‚adnoÅ›ci otrzymanego
wyniku. W zaleÅ¼noÅ›ci od jakoÅ›ci zastosowanego generatora liczb pseudolosowych,
moÅ¼e on w pewnym momencie zakoÅ„czyÄ‡ bieÅ¼Ä…cÄ… sekwencjÄ™ i rozpoczÄ…Ä‡
zwracanie liczb z tej samej sekwencji od poczÄ…tku. PoniewaÅ¼ celem
tego testu nie jest zbadanie dokÅ‚adnoÅ›ci przybliÅ¼enia liczby $\pi$
a porÃ³wnanie szybkoÅ›ci obliczeÅ„ w klastrze i na pojedynczym wÄ™Åºle,
jako generator zostaÅ‚a wybrana klasa \dcscode{System.Random}%
\footnote{%
\begin{minipage}[t]{1\columnwidth}%
Implementacja klasy \dcscode{System.Random} w .NET Framework 4.0
posiada kilka cech, ktÃ³re sprawiajÄ…, Å¼e nie nadaje siÄ™ ona do zastosowaÅ„,
w ktÃ³rych oczekujemy ciÄ…gu o wysokim stopniu losowoÅ›ci. 
\begin{itemize}
\item Inicjowanie generatora przez domyÅ›lny konstruktor uÅ¼ywa aktualnego
czasu. Z tego powodu utworzenie wielu jego instancji w krÃ³tkim czasie,
np. w Å›rodowisku wielowÄ…tkowym, moÅ¼e prowadziÄ‡ do otrzymania takich
samych sekwencji liczb. Co wiÄ™cej, przestrzeÅ„ inicujujÄ…ca generator
jest stosunkowo maÅ‚a -- majÄ…c juÅ¼ $2^{16}$ instancji generatora zainicjowanego
losowymi wartoÅ›ciami istnieje duÅ¼e prawdopodobieÅ„stwo otrzymania tej
samej sekwencji wielokrotnie.
\item Dla niektÃ³rych wartoÅ›ci parametrÃ³w metoda \dcscode{Next} zwraca sekwencje,
ktÃ³rych rozkÅ‚ad nie jest rÃ³wnomierny. 
\end{itemize}
W zastosowaniach, w ktÃ³rych wymagane jest bezpieczeÅ„stwo zaleca siÄ™
stosowanie implementacji opartych o metody kryptograficzne, np. \dcscode{System.Security.Cryptography.RNGCryptoServiceProvider}.%
\end{minipage}%
}.

Otrzymane wyniki i ich analiza zostaÅ‚y przedstawione w rozdziale \dcsemph{Testy wydajnoÅ›ciowe i jakoÅ›ciowe}
w punkcie \ref{sub:performance-Obliczanie-przyblizenia-Pi}.
