
\chapter{Implementacja}

\label{chap:implementation}Projekt systemu zakÅ‚adaÅ‚ napisanie go
w jÄ™zyku C\# w Å›rodowisku .NET Framework 4.5~\cite{Microsoft.NET}
i umoÅ¼liwienie wykonywania kodu uÅ¼ytkownika z bibliotek skompilowanych
do kodu zarzÄ…dzalnego dla .NET Framework w wersji nie nowszej niÅ¼
4.5. Testy wykonania kodu uÅ¼ytkownika zostaÅ‚y przeprowadzone z uÅ¼yciem
aplikacji napisanych w jÄ™zykach C\# oraz F\#. 

System Bluepath dziaÅ‚a na klastrze wÄ™zÅ‚Ã³w obliczeniowych. Na kaÅ¼dym
wÄ™Åºle musi zostaÄ‡ uruchomiona binarnie zgodna wersja aplikacji (w
stopniu umoÅ¼liwiajÄ…cym wykonanie dowolnej metody z dowolnej klasy
bÄ™dÄ…cej czÄ™Å›ciÄ… procesu za pomocÄ… zserializowanego uchwytu otrzymanego
w ramach zlecenia pod pewnymi warunkami opisanymi w punkcie \ref{sec:implementation-Rozproszony-watek}).
W ramach jednego z wÄ…tkÃ³w uruchamiana jest usÅ‚uga nasÅ‚uchujÄ…ca wywoÅ‚aÅ„
-- zleceÅ„, zapytaÅ„ przychodzÄ…cych od pozostaÅ‚ych wÄ™zÅ‚Ã³w.


\section{Komunikacja}

W sieci komunikacyjnej w warstwie transportowej dziaÅ‚a protokÃ³Å‚ TCP
\cite{rfc675,rfc793,rfc1122}, ktÃ³ry realizuje gwarancje niezawodnego
dostarczenia wiadomoÅ›ci z uÅ¼yciem mechanizmu potwierdzeÅ„ i retransmisji
zgodnie z zaÅ‚oÅ¼eniem przyjÄ™tym w punkcie \ref{sub:concept-Komunikacja}
ppkt. 1. Komunikacja miÄ™dzy wÄ™zÅ‚ami zostaÅ‚a zrealizowana w modelu
RPC (pkt. \ref{def:background-RPC}) za pomocÄ… WCF (pkt. \ref{def:background-WCF}).
PoÅ‚Ä…czenia realizowane sÄ… za pomocÄ… protokoÅ‚u HTTP \cite{rfc2616},
a wiadomoÅ›ci sÄ… przesyÅ‚ane zgodnie z protokoÅ‚em SOAP~\cite{W3C-SOAP11,W3C-SOAP12-part0,W3C-SOAP12-part1},
co speÅ‚nia wymagania postawione w punkcie \ref{sub:concept-Komunikacja}
ppkt. 2. Z~uwagi na losowy wybÃ³r numerÃ³w portÃ³w zaÅ‚oÅ¼ono, Å¼e na maszynach
nie dziaÅ‚a zapora ogniowa (pkt. \ref{def:background-Firewall}) blokujÄ…ca
poÅ‚Ä…czenia przychodzÄ…ce na portach o wysokich numerach. W sieci nie
moÅ¼e takÅ¼e dziaÅ‚aÄ‡ mechanizm NAT, co uniemoÅ¼liwiÅ‚oby realizacjÄ™ bezpoÅ›redniej
komunikacji miÄ™dzy wÄ™zÅ‚ami. 

WÄ…tek nasÅ‚uchujÄ…cy jest reprezentowany przez obiekt klasy \dcscode{BluepathListener}.
WewnÄ™trznie tworzy on instancjÄ™ klasy faktycznie nasÅ‚uchujÄ…cej na
losowym porcie na wiadomoÅ›ci zgodne z interfejsem \dcscode{IRemoteExecutorService},
ktÃ³ry zostaÅ‚ przedstawiony na listingu \ref{lis:implementation-Interfejs-IRemoteExecutorService},
a szczegÃ³Å‚owy opis protokoÅ‚u znajduje siÄ™ w punkcie \ref{sec:implementation-Wykonawca}
poÅ›wiÄ™conym \dcsname{wykonawcom}. Dokonywana jest teÅ¼ rejestracja
w \dcsname{usÅ‚udze odnajdywania wÄ™zÅ‚Ã³w}. JeÅ¼eli w ramach jednego
procesu zostanie utworzone kilka instancji klasy \dcscode{BluepathListener}
kaÅ¼da z nich bÄ™dzie nasÅ‚uchiwaÅ‚a na innym porcie i posiadaÅ‚a wÅ‚asnÄ…
kolekcjÄ™ \dcsname{lokalnych wykonawcÃ³w}. Lista znanych \dcsname{zdalnych wykonawcÃ³w}
jest wspÃ³Å‚dzielona w ramach procesu przez wszystkie wÄ…tki nasÅ‚uchujÄ…ce. 

W systemie kaÅ¼dy wÄ™zeÅ‚ moÅ¼e komunikowaÄ‡ siÄ™ z dowolnym innym, o ile
zna jego adres IP i numer portu, pod ktÃ³rym dziaÅ‚a usÅ‚uga. Komunikaty,
zarÃ³wno wywoÅ‚ania (ang.~\dcsemph{request}) jak i wywoÅ‚ania zwrotne
(ang.~\dcsemph{callback}), majÄ… charakter asynchroniczny. Istnieje
rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ wyÅ‚Ä…czenia wywoÅ‚aÅ„ zwrotnych i przeÅ‚Ä…czenia systemu
w tryb pracy z odpytywaniem (ang.~\dcsemph{polling}). Wprowadza
on dodatkowe opÃ³Åºnienia, co dyskwalifikuje go w przypadku prowadzenia
w klastrze faktycznych obliczeÅ„, znajduje jednak zastosowanie w niektÃ³rych
scenariuszach realizowanych w~Å›rodowisku testowym.

\inputencoding{latin2}\begin{lstlisting}[caption={Interfejs IRemoteExecutorService},label={lis:implementation-Interfejs-IRemoteExecutorService},language={[Sharp]C},numbers=left]
[ServiceContract]
public interface IRemoteExecutorService
{
    [OperationContract]
    Guid Initialize(byte[] methodHandle);

    [OperationContract]
    void Execute(Guid eId, object[] parameters, ServiceUri callbackUri);

    [OperationContract]
    void ExecuteCallback(Guid eid, RemoteExecutorServiceResult executeResult);

    [OperationContract]
    RemoteExecutorServiceResult TryJoin(Guid eId);

    [OperationContract]
    PerformanceStatistics GetPerformanceStatistics();
}
\end{lstlisting}
\inputencoding{utf8}


\section{UsÅ‚uga odnajdywania wÄ™zÅ‚Ã³w}

Obecna implementacja zawiera usÅ‚ugÄ™ odnajdywania wÄ™zÅ‚Ã³w zrealizowanÄ…
w sposÃ³b scentralizowany, a kaÅ¼dy z wÄ™zÅ‚Ã³w podÅ‚Ä…czajÄ…cych siÄ™ do klastra
musi znaÄ‡ adres IP i numer portu, pod ktÃ³rym dziaÅ‚a \dcsname{usÅ‚uga odnajdywania wÄ™zÅ‚Ã³w}.
UsÅ‚uga udostÄ™pnia metody sÅ‚uÅ¼Ä…ce do zarejestrowania siÄ™ wÄ™zÅ‚a (\dcscode{Register}),
wyrejestrowania siÄ™ wÄ™zÅ‚a (\dcscode{Unregister}), pobrania listy
zarejestrowanych w klastrze wÄ™zÅ‚Ã³w (\dcscode{GetAvailableServices}),
oraz pobrania statystyk wydajnoÅ›ci wszystkich wÄ™zÅ‚Ã³w w klastrze (\dcscode{GetPerformanceStatistics}).

\inputencoding{latin2}\begin{lstlisting}[caption={Interfejs ICentralizedDiscoveryService},language={[Sharp]C},numbers=left]
[ServiceContract]
public interface ICentralizedDiscoveryService
{
    [OperationContract]
    ServiceUri[] GetAvailableServices();

    [OperationContract]
    void Register(ServiceUri uri);

    [OperationContract]
    void Unregister(ServiceUri uri);

    [OperationContract]
    Task<Dictionary<ServiceUri, PerformanceStatistics>> GetPerformanceStatistics();
}
\end{lstlisting}
\inputencoding{utf8}


\section{WÄ…tek rozproszony}

\label{sec:implementation-Rozproszony-watek}\dcscode{DistributedThread}
to klasa, ktÃ³rej instancje reprezentujÄ… jednostkÄ™ przetwarzania w
systemie czyli \dcsname{wÄ…tek rozproszony} (patrz \ref{def:background-Rozproszony-watek}).
WÄ…tek taki tworzony jest na podstawie delegatu \dcscode{Func} opakowujÄ…cego
statycznÄ… (nazwanÄ… lub anonimowÄ…) metodÄ™. Liczba parametrÃ³w wejÅ›ciowych
takiej metody to maksymalnie 16 (jest to ograniczenie wprowadzone
przez deklaracje typu \dcscode{Func} dostÄ™pne w .NET Framework).
Wszystkie typy parametrÃ³w oraz typ zwracany muszÄ… byÄ‡ oznaczone atrybutem
\dcscode{Serializable}. PrzykÅ‚ad tworzenia i uruchamiania przez uÅ¼ytkownika
\dcsname{wÄ…tku rozproszonego} z uÅ¼yciem domyÅ›lnego \dcsname{zarzÄ…dcy poÅ‚Ä…czeÅ„}
i \dcsname{planisty} zostaÅ‚ przedstawiony na listingu \ref{lis:implementation-Tworzenie-i-uruchamianie-watku}.

Åšrodowisko zakÅ‚ada izolacjÄ™ pomiÄ™dzy wÄ…tkami: \dcsname{wÄ…tki rozproszone}
dziaÅ‚ajÄ…ce w~ramach jednego procesu-hosta nie mogÄ… komunikowaÄ‡ siÄ™
ze sobÄ… poprzez pamiÄ™Ä‡ operacyjnÄ…, a parametry, z ktÃ³rymi wywoÅ‚ywana
jest metoda sÄ… kopiowane do nowych instancji klas i struktur. WyjÄ…tkiem
jest tutaj dostarczana przez Å›rodowisko \dcsname{pamiÄ™Ä‡ rozproszona}.
W tym przypadku uÅ¼ytkownik powinien stosowaÄ‡ dostarczone wraz z niÄ…
mechanizmy synchronizacji. 

\begin{minipage}[t]{1\textwidth}%
\inputencoding{latin2}\begin{lstlisting}[caption={Tworzenie
i uruchamianie rozproszonego w±tku},label={lis:implementation-Tworzenie-i-uruchamianie-watku},language={[Sharp]C},numbers=left]
var thread = DistributedThread.Create(
    new Func<..., IBluepathCommunicationFramework, ...>((..., bluepath) => { 
        ...
        return ...; 
    }
)); 

thread.Start(...);
\end{lstlisting}
\inputencoding{utf8}%
\end{minipage}


\section{Wykonawca}

\label{sec:implementation-Wykonawca}PoniÅ¼ej opisane zostaÅ‚y szczegÃ³Å‚y
protokoÅ‚u komunikacyjnego (rys. \ref{fig:implementation-Protokol-IRemoteExecutorService})
uÅ¼ywanego przez wÄ™zÅ‚y obliczeniowe oraz szczegÃ³Å‚y implementacji \dcsname{wykonawcÃ³w}.

\begin{figure}
\centering{}\includegraphics{images/diagram-protokolu}\protect\caption{\label{fig:implementation-Protokol-IRemoteExecutorService}Diagram
protokoÅ‚u komunikacyjnego wÄ™zÅ‚Ã³w obliczeniowych}
\end{figure}



\subsection{Inicjalizacja}

KaÅ¼dy wykonawca jest identyfikowany przez \dcscode{eid} (ang. \dcsemph{Executor ID})
-- unikalnÄ… 128-bitowÄ… liczbÄ™ (GUID, ang. \dcsemph{Globally Unique Identifier}),
przy czym instancja \dcsname{zdalnego wykonawcy} uÅ¼ywa takiego samego
identyfikatora jak \dcsname{lokalny wykonawca}, ktÃ³ry zostaÅ‚ zainicjowany
do wykonania kodu uÅ¼ytkownika. WiadomoÅ›Ä‡ inicjujÄ…ca wÄ…tek \dcscode{Initialize}
zawiera element \dcscode{methodHandle}, w ktÃ³rym przesyÅ‚any jest
zserializowany binarnie i zapisany w kodowaniu Base64 uchwyt do metody.
W odpowiedzi przesyÅ‚any jest identyfikator wykonawcy. Listing \ref{lis:implementation-SOAP-Initialize}
przedstawia w skrÃ³conej formie przykÅ‚adowÄ… przechwyconÄ… kopertÄ™ SOAP
z wiadomoÅ›ciÄ… \dcscode{Initialize}.

\inputencoding{latin2}\begin{lstlisting}[caption={Koperta SOAP -- inicjalizacja
zdalnego wykonawcy},label={lis:implementation-SOAP-Initialize},language=XML,numbers=left]
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
	<s:Body>
		<Initialize xmlns="http://tempuri.org/">
			<methodHandle>AAEAAAD/////AQAAAAAAAAAMAgAAAD9[...]==</methodHandle>
		</Initialize>
	</s:Body>
</s:Envelope>
\end{lstlisting}
\inputencoding{utf8}

Listing \ref{lis:implementation-SOAP-Initialize-decBase64} prezentuje
fragment uchwytu do metody po zdekodowaniu i usuniÄ™ciu znakÃ³w spoza
drukowalnego zestawu symboli ASCII. DistributedPI to przykÅ‚adowy program
opisany szerzej w punkcie \ref{sec:Przykladowe-zastosowania-liczba-pi}.
Uchwyt dotyczy metody anonimowej (stÄ…d wygenerowana przez kompilator
nazwa \dcscode{b\_\_0}) zdefiniowanej w klasie \dcscode{Bluepath.DistributedPI.Program},
ktÃ³ra jako parametr przyjmuje \dcscode{int} (\dcscode{System.Int32})
a typem zwracanym jest \dcscode{long} (\dcscode{System.Int64}). 

\inputencoding{latin2}\begin{lstlisting}[caption={Zdekodowany fragment
uchwytu do anonimowej metody},label={lis:implementation-SOAP-Initialize-decBase64},language=Assembler,numbers=left]
[...] System.Type[]
<RunTest>b__0 MBluepath.DistributedPI, Version=1.0.0.0, Culture=neutral, 
PublicKeyToken=null Bluepath.DistributedPI.Program
Int64 <RunTest>b__0(Int32) (System.Int64 <RunTest>b__0(System.Int32) 
System.UnitySerializationHolder Data	UnityType AssemblyName
\end{lstlisting}
\inputencoding{utf8}


\subsection{PrzesÅ‚anie parametrÃ³w, wykonanie}

W kolejnej wiadomoÅ›ci, po inicjalizacji, wÄ™zeÅ‚ zlecajÄ…cy przesyÅ‚a
parametry wywoÅ‚ania metody. Przechwycona koperta z komunikatem \dcscode{Execute}
znajduje siÄ™ na listingu \ref{lis:implementation-SOAP-Execute}. Warto
zauwaÅ¼yÄ‡, Å¼e ustawiona jest tutaj wartoÅ›Ä‡ pola \dcscode{callbackUri},
co~oznacza, Å¼e wÄ™zeÅ‚ wywoÅ‚ujÄ…cy otrzyma komunikat \dcscode{ExecuteCallback}
po zakoÅ„czeniu przetwarzania po zdalnej stronie.

\inputencoding{latin2}\begin{lstlisting}[caption={Koperta SOAP -- przes³anie
paramterów},label={lis:implementation-SOAP-Execute},breaklines=true,language=XML,numbers=left]
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
	<s:Body>
		<Execute xmlns="http://tempuri.org/">
			<eId>6a3ff0e2-601b-4683-a163-7f6da037c762</eId>
			<parameters xmlns:a="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
				<a:anyType i:type="b:int" xmlns:b="http://www.w3.org/2001/XMLSchema">10000</a:anyType>
			</parameters>
			<callbackUri xmlns:a="http://schemas.datacontract.org/2004/07/Bluepath.Services" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
				<a:Address>http://192.168.0.7:51000/BluepathExecutorService.svc</a:Address>
				<a:BindingType>BasicHttpBinding</a:BindingType>
			</callbackUri>
		</Execute>
	</s:Body>
</s:Envelope>
\end{lstlisting}
\inputencoding{utf8}

Lokalny wykonawca szereguje wÄ…tki do wykonania uÅ¼ywajÄ…c dostarczonej
przez Å›rodowisko .NET Framework puli wÄ…tkÃ³w (\dcscode{ThreadPool}).
PodejÅ›cie to ma swoje wady -- tracona jest kontrola nad tak stworzonymi
wÄ…tkami, nie moÅ¼na ich przerwaÄ‡ lub sprawdziÄ‡ ich stanu (uniemoÅ¼liwia
to np. realizacjÄ™ detekcji zakleszczenia). Biblioteka Bluepath zapewnia,
Å¼e w przypadku, gdy w kodzie uÅ¼ytkownika wystÄ…pi wyjÄ…tek, zostanie
on przechwycony, zserializowany i udostÄ™pniony wywoÅ‚ujÄ…cemu wÄ…tkowi
do odczytu.


\subsection{WywoÅ‚anie zwrotne}

Po zakoÅ„czeniu metody w trybie z wywoÅ‚aniem zwrotnym, zdalna strona
przesyÅ‚a wynik, ew. wyjÄ…tki oraz czas jaki zajÄ™Å‚o przetwarzanie do
zlecajÄ…cej maszyny. PrzykÅ‚adowy komunikat \dcscode{ExecuteCallback}
przedstawia listing \ref{lis:implementation-SOAP-ExecuteCallback}.

\noindent %
\begin{minipage}[t]{1\textwidth}%
\inputencoding{latin2}\begin{lstlisting}[caption={Koperta SOAP -- wywo³anie
zwrotne z wynikiem},label={lis:implementation-SOAP-ExecuteCallback},breaklines=true,language=XML,numbers=left]
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
	<s:Body>
		<ExecuteCallback xmlns="http://tempuri.org/">
			<eid>6a3ff0e2-601b-4683-a163-7f6da037c762</eid>
			<executeResult xmlns:a="http://schemas.datacontract.org/2004/07/Bluepath.Services" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
				<a:ElapsedTime>PT0.0125743S</a:ElapsedTime>
				<a:Error i:nil="true" xmlns:b="http://schemas.datacontract.org/2004/07/System"/>
				<a:ExecutorState>Finished</a:ExecutorState>
				<a:Result i:type="b:long" xmlns:b="http://www.w3.org/2001/XMLSchema">7857</a:Result>
			</executeResult>
		</ExecuteCallback>
	</s:Body>
</s:Envelope>
\end{lstlisting}
\inputencoding{utf8}%
\end{minipage}


\section{Planista}

Wraz z systemem dostarczone zostaÅ‚y nastÄ™pujÄ…ce typy \dcsname{planistÃ³w}: 
\begin{itemize}
\item \dcscode{ThreadNumberScheduler} -- szereguje zadania na najmniej
obciÄ…Å¼onym wÄ™Åºle pod wzglÄ™dem liczby wykonywanych na nim wÄ…tkÃ³w,
\item \dcscode{RoundRobinScheduler} -- szereguje zadania korzystajÄ…c z
algorytmu cyklicznego (ang.~\dcsemph{round robin}) \cite{Tannenbaum-SOP}.
\end{itemize}
Wszystkie implementacje \dcsname{planisty} muszÄ… implementowaÄ‡ interfejs
\dcscode{IScheduler} dziÄ™ki czemu moÅ¼na zastosowaÄ‡ implementacjÄ™
\dcsname{planisty} dostosowanÄ… do potrzeb przetwarzania i jest jednym
z elementÃ³w moduÅ‚owoÅ›ci systemu. PoniÅ¼ej zostaÅ‚y szczegÃ³Å‚owo opisane
implementacje planistÃ³w dostarczonych z systemem. 


\subsection{Szeregowanie zadaÅ„ w oparciu o obciÄ…Å¼enie wÄ™zÅ‚Ã³w}

\label{sub:implementacja-szeregowanie-zadan-threadcount}Jednym z
podstawowych sposobÃ³w szeregowania zadaÅ„ jest prÃ³ba rÃ³wnomiernego
rozÅ‚oÅ¼enia obciÄ…Å¼enia wÄ™zÅ‚Ã³w. ZakÅ‚adajÄ…c, Å¼e wszystkie zadania majÄ…
podobny rozmiar, jako miarÄ™ obciÄ…Å¼enia konkretnego wÄ™zÅ‚a moÅ¼na przyjÄ…Ä‡
liczbÄ™ zadaÅ„, ktÃ³re sÄ… obecnie przetwarzane, lub oczekujÄ… na rozpoczÄ™cie
przetwarzania.

W przykÅ‚adowej implementacji dostarczanej wraz z bibliotekÄ… \dcsname{Bluepath}
informacje o obecnym obciÄ…Å¼eniu wÄ™zÅ‚Ã³w sÄ… okresowo odÅ›wierzane prz
pomocy \dcsname{usÅ‚ugi odnajdywania wÄ™zÅ‚Ã³w}. W zaleÅ¼noÅ›ci od
szybkoÅ›ci tworzenia nowych \dcsname{wÄ…tkÃ³w rozproszonych} oraz
czÄ™stotliwoÅ›ci odÅ›wierzania informacji o obciÄ…Å¼eniu wÄ™zÅ‚Ã³w lokalne
dane mogÄ… szybko staÄ‡ siÄ™ nieaktualne. MoÅ¼na ten efekt zÅ‚agodziÄ‡ poprzez
zwiÄ™kszanie zapamiÄ™tanego obciÄ…Å¼enia o wysÅ‚ane na dany wÄ™zeÅ‚ wÄ…tki.


\subsection{Szeregowanie zadaÅ„ za pomocÄ… algorytmu cyklicznego}

\label{sub:Implementacja-Szeregowanie-karuzelowy}W pewnych zastosowaniach
pewne zrÃ³wnowarzenie obciÄ…Å¼enia moÅ¼na osiÄ…gnÄ…Ä‡ poprzez zastosowanie
algorytmu cyklicznego. Algorytm ten nie wymaga pobierania informacji
o obciÄ…Å¼eniu wÄ™zÅ‚Ã³w z \dcsname{usÅ‚ugi odnajdywania wÄ™zÅ‚Ã³w}, przez
co posiada mniejszy narzut komunikacyjny od algorytmÃ³w wymagajÄ…cych
tych informacji. 


\section{PamiÄ™Ä‡ rozproszona}

PoniewaÅ¼ celem pracy nie byÅ‚o kompletne implementowanie pamiÄ™ci rozproszonej,
skupiono siÄ™ na wyborze istniejÄ…cego rozwiÄ…zania, ktÃ³re speÅ‚niaÅ‚oby
wymagania zaprezentowane w punkcie \ref{sec:concept-Rozproszona-pami=000119=000107-wsp=0000F3=000142dzielona}.


\subsection{RozwaÅ¼ane rozwiÄ…zania }

\label{sub:implementation-Pamiec-rozproszona-rozwazane-rozwiazania}PoczÄ…tkowo
pod uwagÄ™ brane byÅ‚y nastÄ™pujÄ…ce aplikacje:
\begin{itemize}
\item Memcached \cite{Memcached} -- system dostarczajÄ…cy rozproszonÄ… pamiÄ™Ä‡
przechowujÄ…cÄ… dane w postaci par klucz-wartoÅ›Ä‡. Nie znaleziono aktywnie
rozwijanego klienta dla platformy .NET,
\item Riak \cite{Riak} -- implementacja Amazon Dynamo \cite{Amazon-Dynamo},
odrzucony ze wzglÄ™du na brak API dla .NET Framework,
\item Polyphony \cite{Polyphony-blog-1,Polyphony-blog-2,Polyphony-blog-3,Polyphony-repo}
-- eksperymentalny projekt rozproszonej tablicy haszowej napisany
w jÄ™zyku F\#, nie wybrano ze wzglÄ™du na wczesnorozwojowy charakter
projektu,
\item Rhino DHT \cite{Rhino-DHT} -- implementacja rozproszonej tablicy
haszowej w jÄ™zyku C\#; posiada zaleÅ¼noÅ›ci od Rhino PHT (\dcsemph{persistent hash table})
\cite{Rhino-PHT} oraz Rhino Queues \cite{Rhino-Queues},
\end{itemize}
a w pÃ³Åºniejszym okresie rÃ³wnieÅ¼:
\begin{itemize}
\item Redis \cite{Redis} -- system rozpowszechniany na licencji \dcsemph{open source}
przechowujÄ…cy dane typu klucz-wartoÅ›Ä‡.
\end{itemize}
Pierwszym wybranym rozwiÄ…zaniem byÅ‚o Rhino DHT, ktÃ³re byÅ‚o aktywnie
rozwijane przez rozpoznawalnego autora -- Ayende Rahiena. Niestety,
okazaÅ‚o siÄ™, Å¼e wersjonowanie danych nie zostaÅ‚o w peÅ‚ni zaimplementowane
i nie byÅ‚o moÅ¼liwe wykonanie atomowej operacji ,,odczytaj i zapisz'',
ktÃ³ra byÅ‚a niezbÄ™dna do zrealizowania \dcsname{zamkÃ³w rozproszonych}.
SzczegÃ³Å‚y tego problemu zostaÅ‚y przedstawione w~punkcie \ref{par:problemy-rhino-dht}. 

Kolejnym rozwiÄ…zaniem wziÄ™tym pod uwagÄ™ byÅ‚ Redis -- system autorstwa
Salvatore Sanfilippo oraz Pietera Noordhuisa. Jest uÅ¼ywany na co dzieÅ„
jako mechanizm pamiÄ™ci podrÄ™cznej wielu serwisÃ³w internetowych (m.~in.
caÅ‚a rodzina StackExchange) -- posiada przez to duÅ¼e wsparcie i aktywnie
dziaÅ‚ajÄ…cÄ… spoÅ‚ecznoÅ›Ä‡. Redis potrafi dziaÅ‚aÄ‡ zarÃ³wno jako pojedynczy
proces jak i w trybie master-slave, ponadto rozwijana jest wersja
rozproszona -- Redis Cluster. System ten posiada biblitekÄ™ dla .NET
Framework dostarczonÄ… przez firmÄ™ StackExchange. Redis zostaÅ‚ napisany
dla rodziny systemÃ³w operacyjnych Linux, powstaÅ‚ jednak port tego
systemu do systemu operacyjnego Windows. Problemy, ktÃ³re napotkano
podczas uruchamiania usÅ‚ugi Redis (opisane w punkcie \ref{par:problemy-Windows-Redis})
udaÅ‚o siÄ™ rozwiÄ…zaÄ‡, przez co system ten zostaÅ‚ wykorzystany w ostatecznej
wersji pracy i w testach.


\subsection{Interfejsy pamiÄ™ci rozproszonej}

Definicje \dcsname{pamiÄ™ci rozproszonej} oraz \dcsname{rozszerzonej pamiÄ™ci rozproszonej}
zostaÅ‚y sformalizowane w formie interfejsÃ³w odpowiednio \dcscode{IStorage}
oraz \dcscode{IExtendedStorage}. Interfejs \dcscode{IStorage} wymaga
implementacji metod do operacji na pojedynczych wartoÅ›ciach: \dcscode{Store},
\dcscode{StoreOrUpdate}, \dcscode{Update}, \dcscode{Retrieve} i
\dcscode{Remove} oraz operacji zbiorczych: \dcscode{BulkStore},
\dcscode{BulkStoreOrUpdate}, \dcscode{BulkUpdate}, \dcscode{BulkRetrieve}
i \dcscode{BulkRemove}. Semantyka tych operacji odpowiada operacjom
zdefiniowanym w punkcie \ref{sec:concept-Rozproszona-pami=000119=000107-wsp=0000F3=000142dzielona}.
Wszystkie operacje zdefiniowane w \dcsname{pamiÄ™ci rozproszonej}
i \dcsname{rozszerzonej pamiÄ™ci rozproszonej} pozwalajÄ… na bezpieczne
wspÃ³Å‚bieÅ¼ne wywoÅ‚anie z wielu wÄ…tkÃ³w (ang. \dcsemph{thread-safe}). 

Interfejs \dcscode{IExtendedStorage} rozszerza podstawowy interfejs
\dcscode{IStorage} o operacje pobrania i zwolnienia \dcsname{zamkÃ³w rozproszonych}:
\dcscode{AcquireLock} (w wersji z limitem czasu oczekiwania na pobranie
zamka i bez) oraz \dcscode{ReleaseLock}. 


\subsection{Rozproszone struktury danych i obiekty}

Struktury danych i obiekty, ktÃ³re mogÄ… byÄ‡ wspÃ³Å‚dzielone miÄ™dzy \dcsname{wÄ…tkami rozproszonymi}
zaimplementowane zostaÅ‚y w oparciu o \dcsname{pamiÄ™Ä‡ rozproszonÄ…},
zdefiniowanÄ… za pomocÄ… interfejsu \dcscode{IExtendedStorage} -- pozwoliÅ‚o
to zastosowaÄ‡ \dcsname{zamki rozproszone} w celu zapewnienia poprawnoÅ›ci
przetwarzania -- wspÃ³Å‚bieÅ¼ny dostÄ™p do rozproszonych struktur danych
i obiektÃ³w moÅ¼e byÄ‡ prowadzony zarÃ³wno z wÄ…tkÃ³w jak i \dcsname{wÄ…tkÃ³w rozproszonych}.
KaÅ¼dy obiekt jest identyfikowany przez klucz bÄ™dÄ…cy Å‚aÅ„cuchem znakÃ³w.
W przypadku listy czy sÅ‚ownika na podstawie klucza wywiedzione zostajÄ…
identyfikatory obiektÃ³w skÅ‚adajÄ…cych siÄ™ na danÄ… strukturÄ™ -- zamkÃ³w,
metadanych i poszczegÃ³lnych wartoÅ›ci. 


\subsubsection*{Lista}

Lista implementuje standardowy generyczny interfejs \dcscode{IList<T>}
z przestrzeni nazw \dcscode{System.Collections.Generic}. PrÃ³ba pobrania
enumeratora zwraca obiekt klasy \dcscode{DistributedListEnumerator},
ktÃ³ry umoÅ¼liwia iterowanie po kolekcji. \dcsname{Lista rozproszona}
zostaÅ‚a rozszerzona o operacjÄ™ \dcscode{CopyPartTo} -- jest to odpowiednik
operacji \dcscode{CopyTo} (efektywnej operacji kopiowania caÅ‚ej zawartoÅ›ci
listy do wskazanej tablicy), ktÃ³ry pozwala skopiowaÄ‡ wybrany fragment
listy w sposÃ³b efektywny i atomowy. Operacja ta jest szczegÃ³lnie przydatna
przy przetwarzaniu rozproszonym, gdzie dane znajdujÄ… siÄ™ w wolnej
\dcsname{pamiÄ™ci rozproszonej} (w stosunku do pamiÄ™ci podrÄ™cznej),
a~kaÅ¼dy \dcsname{wÄ…tek rozproszony} przetwarza fragment danych.


\subsubsection*{SÅ‚ownik}

SÅ‚ownik implementuje standardowy generyczny interfejs \dcscode{IDictionary<TKey, TValue>}
z przestrzeni nazw \dcscode{System.Collections.Generic}. PrÃ³ba pobrania
enumeratora zwraca obiekt klasy \dcscode{DistributedDictionaryEnumerator},
ktÃ³ry umoÅ¼liwia iterowanie po kolekcji. 


\subsubsection*{Licznik}

W wielu scenariuszach (przykÅ‚adowy scenariusz opisany w \ref{par:koncepcja-distributed-counter})
przydatnym obiektem moÅ¼e byÄ‡ \dcsname{licznik rozproszony}. Zaimplementowana
klasa \dcscode{DistributedCounter} udostÄ™pnia nastÄ™pujÄ…ce operacje: 
\begin{itemize}
\item \dcscode{GetValue} -- pobiera aktualnÄ… wartoÅ›Ä‡ licznika,
\item \dcscode{SetValue} -- ustawia podanÄ… liczbÄ™ jako wartoÅ›Ä‡ licznika,
\item \dcscode{Increase} -- zwiÄ™ksza wartoÅ›Ä‡ licznika o podanÄ… wartoÅ›Ä‡,
\item \dcscode{Decrease} -- zmniejsza wartoÅ›Ä‡ licznika o podanÄ… wartoÅ›Ä‡,
\item \dcscode{GetAndIncrease} -- atomowo pobiera aktualnÄ… wartoÅ›Ä‡ licznika
i zwiÄ™ksza jÄ… o~wskazanÄ… liczbÄ™, gdzie liczba o ktÃ³rÄ… ma zostaÄ‡ zwiÄ™kszony
licznik moÅ¼e byÄ‡ ujemna.
\end{itemize}

\subsection{Zamki rozproszone}

Odpowiednikiem definicji \dcsname{zamkÃ³w rozproszonych} z punktu
\ref{sub:Koncepcja-Zamki-rozproszone} jest interfejs \dcscode{IStorageLock}.
Zdefiniowane w nim zostaÅ‚y nastÄ™pujÄ…ce operacje:
\begin{itemize}
\item \dcscode{Acquire} -- operacja pobrania zamka. Posiada wariant, ktÃ³ry
pozwala okreÅ›liÄ‡ czas oczekiwania na pobranie zamka -- jeÅ›li czas
ten zostanie przekroczony przed pobraniem zamka uÅ¼ytkownik dostanie
informacjÄ™ o niepowodzeniu i~bÄ™dzie mÃ³gÅ‚ kontynuowaÄ‡ przetwarzanie.
Operacja pobrania zamka bez podania czasu oczekiwania jest blokujÄ…ca
-- przetwarzanie bÄ™dzie kontynuowane dopiero po pobraniu zamka,
\item \dcscode{Release} -- operacja zwolnienia zamka,
\item \dcscode{Wait} -- wykonanie tej operacji powoduje rozpoczÄ™cie oczekiwania
na sygnaÅ‚ (ang.~\dcsemph{pulse}) od innego procesu. Wykonanie tej
operacji powoduje tymczasowe zwolnienie dostÄ™pu do zamka. Po otrzymaniu
sygnaÅ‚u proces prÃ³buje ponownie pobraÄ‡ zamek. Podobnie jak \dcscode{Acquire}
operacja ta posiada wariant, ktÃ³ry pozwala okreÅ›liÄ‡ czas oczekiwania
na sygnaÅ‚,
\item \dcscode{Pulse} i \dcscode{PulseAll} -- wykonanie tych operacji
powoduje wysÅ‚anie sygnaÅ‚u do procesÃ³w oczekujÄ…cych na operacji \dcscode{Wait}.
W pierwszym przypadku sygnaÅ‚ dotrze do conajmniej jednego oczekujÄ…cego
procesu, a w drugim do wszystkich oczekujÄ…cych procesÃ³w.
\end{itemize}
Interfejs \dcscode{IStorageLock} dziedziczy z interfejsu \dcscode{IDisposable}
-- sprawia to, Å¼e zamek moÅ¼na wykorzystaÄ‡ w podobny sposÃ³b jak sÅ‚owo
kluczowe \dcscode{lock}, korzystajÄ…c w tym celu z bloku \dcscode{using},
co przedstawiono na listingu \ref{lis:implementation-Realizacja-sekcji-krytycznej}.
CechÄ… bloku \dcscode{using} jest automatyczne wywoÅ‚anie na jego koÅ„cu
operacji \dcscode{Dispose}, ktÃ³ra w przypadku \dcsname{zamkÃ³w rozproszonych}
powoduje zwolnienie zamka.

\noindent %
\begin{minipage}[t]{1\textwidth}%
\inputencoding{latin2}\begin{lstlisting}[caption={Realizacja
sekcji krytycznej z wykorzystaniem zamka rozproszonego},label={lis:implementation-Realizacja-sekcji-krytycznej},breaklines=true,language=bash,numbers=left]
using(var @lock = storage.AcquireLock("sampleLock"))
{
	// sekcja krytyczna
}
\end{lstlisting}
\inputencoding{utf8}%
\end{minipage}


\section{Logowanie zdarzeÅ„}

\label{sec:implementation-Logowanie-zdarzen}Za zbieranie informacji
na temat zdarzeÅ„ zachodzÄ…cych w systemie odpowiada klasa \dcscode{Log}
udostÄ™pniajÄ…ca m. in. statyczne metody:
\begin{itemize}
\item \dcscode{ExceptionMessage} -- do logowania wyjÄ…tkÃ³w,
\item \dcscode{TraceMessage} -- do logowania pozostaÅ‚ych zdarzeÅ„.
\end{itemize}
Istnieje moÅ¼liwoÅ›Ä‡ przekierowania wszystkich informacji do \dcsname{pamiÄ™ci rozproszonej}.
W~tym celu naleÅ¼y ustawiÄ‡ flagÄ™ \dcscode{WriteToDistributedMemory}
oraz uzupeÅ‚niÄ‡ nazwÄ™ hosta \dcsname{pamiÄ™ci rozproszonej} (\dcscode{DistributedMemoryHost}),
do ktÃ³rego ma odbywaÄ‡ siÄ™ zapis. Warto zwrÃ³ciÄ‡ uwagÄ™, Å¼e tryb pracy
ze zbieraniem historii zdarzeÅ„ w \dcsname{pamiÄ™ci wspÃ³Å‚dzielonej}
moÅ¼e istotnie ograniczaÄ‡ wydajnoÅ›Ä‡ systemu. W celu zmaterializowania
zebranego logu udostÄ™pniona zostaÅ‚a metoda \dcscode{SaveXes}, ktÃ³ra
zapisuje wszystkie zgromadzone w \dcsname{pamiÄ™ci rozproszonej}
zdarzenia do pliku XML w formacie OpenXES. 

Implementacja zapisu zdarzeÅ„ do pliku XML zostaÅ‚a wykonana na podstawie
zmodyfikowanych plikÃ³w XSD (pkt. \ref{def:background-XSD}) udostÄ™pnionych
wraz z bibliotekÄ… OpenXES \cite{OpenXES} w wersji 2.0 (przyczyny
i sposÃ³b modyfikacji zostaÅ‚ opisany w punkcie \ref{sub:problemy-Implementacja-standardu-OpenXES-z-XSD}).
Szkielet klas zostaÅ‚ wygenerowany przy uÅ¼yciu narzÄ™dzia XML Schema
Definition Tool \cite{XML-Schema-Definition-Tool} (\dcscode{xsd.exe})
dostarczanego wraz ze Å›rodowiskiem programistycznym .NET Framework
4.5.1. PrzykÅ‚ad uÅ¼ycia programu \dcscode{xsd.exe} zostaÅ‚ zaprezentowany
na listingu \ref{lis:implementation-Skrypt-generuj=000105cy-klasy-z-XSD}. 

\noindent %
\begin{minipage}[t]{1\textwidth}%
\inputencoding{latin2}\begin{lstlisting}[caption={Skrypt
generuj±cy klasy w jêzyku C\# na podstawie pliku XSD dla formatu OpenXES },label={lis:implementation-Skrypt-generuj=000105cy-klasy-z-XSD},breaklines=true,language=bash,numbers=left]
"c:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\xsd.exe" xes.xsd /classes /o:../Bluepath/Reporting/ 
"c:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\xsd.exe" xesext.xsd /classes /o:../Bluepath/Reporting/
\end{lstlisting}
\inputencoding{utf8}%
\end{minipage}

Wszystkie zdarzenia zachodzÄ…ce w systemie zostaÅ‚y pogrupowane w tkw.
\dcsname{aktywnoÅ›ci} (ang.~\dcsemph{activity}). Rodzaje aktywnoÅ›ci
zachodzÄ…cych w systemie zostaÅ‚y zdefiniowane w formie typu wyliczeniowego
\dcscode{Bluepath.Reporting.Log.Activity}, obejmuje on m. in.:
\begin{itemize}
\item \dcscode{Service\_is\_ready} -- zgÅ‚oszenie przez wÄ™zeÅ‚ gotowoÅ›ci
do przyjÄ™cia zleceÅ„,
\item \dcscode{Local\_executor\_started\_running\_user\_code} -- rozpoczÄ™cie
wykonywania kodu uÅ¼ytkownika w ramach rozproszonego wÄ…tku,
\item \dcscode{Local\_executor\_finished\_running\_user\_code} -- zakoÅ„czenie
wykonywania kodu uÅ¼ytkownika na wÄ™Åºle,
\item \dcscode{Sending\_callback\_with\_result} -- wysÅ‚anie wywoÅ‚ania zwrotnego
z wynikiem dziaÅ‚ania wÄ…tku.
\end{itemize}
Wszystkie zdarzenia, ktÃ³re sÄ… maÅ‚o istotne dla analizy procesu mogÄ…
byÄ‡ grupowane w ramach aktywnoÅ›ci \dcscode{Info} i powinny zostaÄ‡
odfiltrowane w pierwszej fazie analizy. JeÅ¼eli uÅ¼ytkownik chce uÅ¼yÄ‡
wÅ‚asnej nazwy dla zdarzenia, moÅ¼e to zrobiÄ‡ korzystajÄ…c z aktywnoÅ›ci
\dcscode{Custom}, a wÅ‚aÅ›ciwÄ… nazwÄ™ przekazaÄ‡ jako parametr \dcscode{message}
do metody logowania zdarzeÅ„. 

Format XES definiuje dla zdarzeÅ„ w logu \dcsname{zasÃ³b} (ang.~\dcsemph{resource})
-- w przypadku biblioteki \dcsname{Bluepath} wartoÅ›ciÄ… tego pola
jest zawsze wykonawca, ktÃ³ry dokonaÅ‚ wpisu, korzystajÄ…c z jego unikalnego
identyfikatora \dcscode{eid}. Implementacja zakÅ‚ada moÅ¼liwoÅ›Ä‡ skrÃ³cenia
zapisu do n ostatnich znakÃ³w skÅ‚adajÄ…cych siÄ™ na identyfikator w celu
uÅ‚atwienia analizy przez czÅ‚owieka. MoÅ¼e to potencjalnie wpÅ‚ynÄ…Ä‡ na
faÅ‚szywe sklasyfikowanie rÃ³Å¼nych zasobÃ³w jako tego samego w wyniku
kolizji tak skonstruowanych identyfikatorÃ³w.

ZaleÅ¼noÅ›ci czasowe sÄ… istotnÄ… czÄ™Å›ciÄ… analizy przebiegu procesu. Z
wykorzystaniem serwerÃ³w czasu implementujÄ…cych protokÃ³Å‚ NTP (ang.
\dcsemph{network time protocol}) \cite{rfc5905} moÅ¼liwe jest zsynchronizowanie
zegarÃ³w wÄ™zÅ‚Ã³w w klastrze z dokÅ‚adnoÅ›ciÄ… do milisekund (przy duÅ¼ych
odlegÅ‚oÅ›ciach od serwera czasu -- dziesiÄ…tek milisekund) \cite{Mills-NTP-IEEE-Trans}.
MoÅ¼e to byÄ‡ niewystarczajÄ…ce do jednoznacznego okreÅ›lenia porzÄ…dku
zdarzeÅ„. Klasa \dcscode{Log} zawiera flagÄ™ \dcscode{monotonicallyIncreasingLogTime},
ktÃ³rej ustawienie uniemoÅ¼liwia zapisanie dwÃ³ch zdarzeÅ„ z tym samym
znacznikiem czasowym poprzez realizowanie dodatkowych operacji podczas
zapisu do logu:
\begin{itemize}
\item pobranie \dcsname{zamka rozproszonego},
\item odczyt ostatnio zapisanej wartoÅ›ci znacznika czasowego z \dcsname{pamiÄ™ci rozproszonej},
\item w przypadku gdy lokalna wartoÅ›Ä‡ znacznika jest mniejsza lub rÃ³wna
odczytanemu, jest ona zamieniana na odczytanÄ… wartoÅ›Ä‡ zwiÄ™kszonÄ… o
1 milisekundÄ™,
\item zapis bieÅ¼Ä…cej wartoÅ›ci znacznika czasowego do \dcsname{pamiÄ™ci rozproszonej},
\item zwolnienie \dcsname{zamka rozproszonego}.
\end{itemize}



\section{Interfejs do komunikacji z systemem}

Aby skorzystaÄ‡ z funkcji udostÄ™pnianych przez system (jak np. pobranie
identyfikatora \dcsname{wykonawcy} czy dostÄ™p do \dcsname{pamiÄ™ci rozproszonej})
wewnÄ…trz \dcsname{wÄ…tku rozproszonego}, uÅ¼ytkownik musi uzyskaÄ‡
przeznaczony do tego obiekt. System automatycznie wstrzykuje go do
metod jako jeden z parametrÃ³w -- wystarczy, by byÅ‚ on typu \dcscode{IBluepathCommunicationFramework}.
UÅ¼ytkownika ma rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ zapisywania wÅ‚asnych zdarzeÅ„ zachodzÄ…cych
w aplikacji do logu z uÅ¼yciem opisanej w punkcie \ref{sec:implementation-Logowanie-zdarzen}
statycznej klasy \dcscode{Log}.


\section{Dystrybucja aplikacji w klastrze}

\label{sec:implementation-Skrypt-Send-Folder}PowerShell Remoting
\cite{PS-Remoting} to usÅ‚uga umoÅ¼liwiajÄ…ca wykonanie na zdalnych
maszynach pojedynczych komend lub stworzenie peÅ‚nej zdalnej sesji
PowerShell. Automatyzacja procesu dystrybucji plikÃ³w binarnych systemu
w klastrze zostaÅ‚a zrealizowana za pomocÄ… zestawu skryptÃ³w: \dcspath{Send-Folder}
do przesyÅ‚ania caÅ‚ych folderÃ³w i \dcspath{Send-File} do przesyÅ‚ania
pojedynczych plikÃ³w, z ktÃ³rego korzysta ten pierwszy. 

Skrypt do wysyÅ‚ania pojedynczych plikÃ³w zostaÅ‚ zaczerpniÄ™ty z ksiÄ…Å¼ki
\cite{Windows-PowerShell-Cookbook}. Przyjmuje 3 parametry: Å›cieÅ¼kÄ™
do pliku ÅºrÃ³dÅ‚owy znajdujÄ…cego siÄ™ na lokalnej maszynie, Å›cieÅ¼kÄ™ docelowÄ…
na zdalnej maszynie oraz referencjÄ™ do obiektu zdalnej sesji. Plik
jest wczytywany do pamiÄ™ci jako tablica bajtÃ³w, nastÄ™pnie jego transfer
odbywa siÄ™ strumieniowo w blokach o rozmiarze 1 MB. Po zrekonstruowaniu
tablicy bajtÃ³w na zdalnej stronie jest ona zapisywana na dysk we wskazanej
lokalizacji.

Skrypt do wysyÅ‚ania folderÃ³w przedstawiony na listingu \ref{lis:implementation-Send-Folder}
przyjmuje jako parametry: 
\begin{itemize}
\item adres zdalnego komputera (\dcscode{-server}), 
\item opcjonalnie port, na ktÃ³rym nasÅ‚uchuje usÅ‚uga PowerShell Remoting
(\dcscode{-port}), 
\item nazwÄ™ uÅ¼ytkownika (\dcscode{-user}), 
\item hasÅ‚o (\dcscode{-password}), 
\item Å›cieÅ¼kÄ™ do folderu ÅºrÃ³dÅ‚owego na lokalnej maszynie (\dcscode{-source}), 
\item oraz Å›cieÅ¼kÄ™ do folderu docelowego na zdalnej maszynie (\dcscode{-destination}). 
\end{itemize}
Skrypt tworzy obiekt zdalnej sesji uwierzytelniajÄ…c siÄ™ poprzez podanÄ…
nazwÄ™ uÅ¼ytkownika i hasÅ‚o. W celu uproszczenia etapu konfiguracji
Å›rodowiska, do wywoÅ‚ania metody \dcscode{New-PSSession} moÅ¼na dodaÄ‡
przeÅ‚Ä…cznik \dcscode{-SessionOption} z parametrem \dcscode{New-PSSessionOption -SkipCACheck}.
Opcja ta powoduje jednak obniÅ¼enie poziomu bezpieczeÅ„stwa poprzez
dopuszczenie niezaufanych certyfikatÃ³w maszyn. NastÄ™pnie pobierana
jest lista plikÃ³w we wskazanym lokalnym folderze i dla kaÅ¼dego z plikÃ³w
wywoÅ‚ywany skrypt \dcspath{Send-File}. Pomijane przy tym sÄ… pliki
z symbolami (\dcspath{.pdb}), poniewaÅ¼ ich rozmiar jest znaczÄ…cy
w stosunku do rozmiaru plikÃ³w samej aplikacji, a nie byÅ‚o konieczne
podÅ‚Ä…czanie \dcsemph{debuggera} do procesÃ³w pracujÄ…cych na zdalnych
maszynach. Po zakoÅ„czeniu przesyÅ‚ania plikÃ³w zdalna sesja jest zamykana.
Warto zauwaÅ¼yÄ‡, Å¼e skrypt \dcspath{Send-Folder} moÅ¼na wywoÅ‚aÄ‡ wielokrotnie
przekazujÄ…c w parametrze -server kolejne adresy maszyn, aby rozdystrybuowaÄ‡
pliki w caÅ‚ym klastrze.

\inputencoding{latin2}\begin{lstlisting}[caption={Skrypt przesy³aj±cy pliki ze
wskazanego folderu na zdaln± maszynê},label={lis:implementation-Send-Folder},language=bash,numbers=left]
param (
	[string]$server = $(throw "-server is required."),
	[int]$port = 5986,
	[string]$user = $(throw "-user is required."),
	[string]$password = $(throw "-password is required."),
	[string]$source = $(throw "-source is required."),
	[string]$destination = $(throw "-destination is required.")
)

$secPassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential($user, $secPassword)
$uri = New-Object System.Uri("https://" + $server + ":" + $port)

$session = New-PSSession -ConnectionUri $uri -Credential $credential

Get-ChildItem -Path $source -File | Foreach-Object {
	if ($_.Extension -ne ".pdb") {
		$target = $destination + $_.Name
		.\Send-File.ps1 $_.FullName $target $session
	}
}

Disconnect-PSSession $session
\end{lstlisting}
\inputencoding{utf8}
