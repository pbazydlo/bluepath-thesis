#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Przykładowe zastosowania
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:applications"

\end_inset

W tym rozdziale przedstawione zostaną przykladowe zastosowania systemu Bluepath.
 Na bazie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątków rozproszonych
\end_layout

\end_inset

, 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

 i nadbudowanych nad nią abstrakcji listy i słownika przygotowane zostały
 projekty:
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
DLINQ
\end_layout

\end_inset

 (ang.
\begin_inset space ~
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
Distributed Language Integrated Query
\end_layout

\end_inset

) -- dostawca metod manipulacji kolekcji w sposób zgodny z obecnym już w
 środowisku .NET dla standardowych, nierozproszonych kolekcji, 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
MapReduce
\end_layout

\end_inset

 -- abstrakcja specjalizowana do uruchamiania zadań w modelu mapowania i
 redukcji z możliwością zlecania zadań bez konieczności ponownej kompilacji
 systemu i dystrybuowania nowej wersji plików wykonywalnych na węzły,
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
System uzupełniania wyrazów
\end_layout

\end_inset

 -- system przygotowujący na podstawie podanej kolekcji dokumentów bazę
 prefiksów, która jest wykorzystywana do realizacji systemu podpowiedzi
 słów na podstawie pierwszych liter wpisywanych przez użytkownika,
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
Obliczanie przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset


\end_layout

\end_inset

 -- algorytm obliczający przybliżoną wartość liczby 
\begin_inset Formula $\pi$
\end_inset

, który umożliwił przeprowadzenie testów porównawczych szybkości obliczeń
 w klastrze bez wykorzystania 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

 w stosunku do obliczeń prowadzonych na pojedynczym węźle.
\end_layout

\begin_layout Section
DLINQ
\end_layout

\begin_layout Standard
Jednym z przykładowych zastosowań biblioteki Bluepath jest Distributed Language
 Integrated Query (DLINQ) -- zbiór metod roszerzających możliwości operowania
 na kolekcjach bazowanych na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

.
 Obecna implementacja służy jako przykład (ang.
\begin_inset space ~
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
proof of concept
\end_layout

\end_inset

) wykorzystania możliwości dostarczanych przez bibliotekę Bluepath i dlatego
 dostarcza implementację podzbioru metod standardowego zestawu LINQ:
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

 -- operacja ta pozwala przetransformować obiekt, np.
 wybierając jedynie podzbiór jego atrybutów, lub zmieniając typ obiektu,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SelectMany
\end_layout

\end_inset

 -- operacja podobna do 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

 z tą różnicą, że pojedynczy obiekt w wyniku transformacji zmieniany jest
 w kolekcję obiektów, a powstałe w ten sposób kolekcje są łączone w jedną,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Where
\end_layout

\end_inset

 -- operacja ta pozwala wyfiltrować te obiekty, które spełniają podany warunek,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GroupBy
\end_layout

\end_inset

 -- operacja pozwalająca grupować obiekty według zadanego klucza,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Count
\end_layout

\end_inset

 -- operacja zliczające obiekty spełniające zadany warunek.
 
\end_layout

\begin_layout Standard
Operacje te mogą być wykonywane zarówno na dostarczonej z biblioteką Bluepath
 liście rozproszonej (opisanej w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:----Koncepcja-wspoldzielone-struktury-danych"

\end_inset

) jak i na wszystkich obiektach implementujących interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IEnumerable
\end_layout

\end_inset

.
 W drugim przypadku kolekcja źródłowa zostanie najpierw przetransformowana
 do listy rozproszonej, a następnie poddana dalszemu przetwarzaniu.
\end_layout

\begin_layout Standard
Sposób wykorzystania rozszerzeń DLINQ jest wzorowany na Parallel Language
 Integrated Query (PLINQ).
 Aby poddać kolekcję przetwarzaniu rozproszonemu wykonujemy najpierw metodę
 rozszerzającą 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AsDistributed
\end_layout

\end_inset

.
 Metoda ta posiada jeden obowiązkowy argument -- obiekt zapewniający dostęp
 do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

.
 Następnie na otrzymanym z tej metody obiekcie można wykonywać operacje
 zdefiniowane w DLINQ.
 Należy jednak mieć na uwadze, że operacje te podlegają założeniom biblioteki
 Bluepath i funkcje podawane jako argumenty muszą być funkcjami statycznymi.
 Na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Transformacja-kolekcji-DLINQ"

\end_inset

 przedstawiono przykładowy kod poddający kolekcję transformacji przy użyciu
 metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Transformacja-kolekcji-DLINQ"

\end_inset

Transformacja kolekcji przypomocy metod dostarczonych w DLINQ
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var inputCollection = new List<double>(100);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

var processedCollection = (from num in inputCollection.AsDistributed(storage)
 select Math.Sqrt(num)).ToList();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W implementacji DLINQ można wyróżnić 3 podstawowe klasy: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedQuery
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedEnumerable
\end_layout

\end_inset

 oraz 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
UnaryQueryOperator
\end_layout

\end_inset

.
 Zostały one dokładniej opisane w poniższych punktach.
\end_layout

\begin_layout Subsection
DistributedQuery
\end_layout

\begin_layout Standard
W celu zapewnienia jednoznacznego rozróżnienia pomiędzy metodami LINQ, oraz
 DLINQ wprowadzono klasę 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedQuery
\end_layout

\end_inset

.
 Klasa ta częściowo implementuje interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IEnumerable
\end_layout

\end_inset

 zapewniając powiązania pomiędzy metodami tego interfejsu.
 Stanowi ona bazę z której wywodzą się wszystkie klasy realizujące poszczególne
 wywołania DLINQ (np.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

) co pozwala na wykonywanie tych samych metod na instancjach różnych klas
 składowych DLINQ.
\end_layout

\begin_layout Subsection
DistributedEnumerable
\end_layout

\begin_layout Standard
Statyczna klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedEnumerable
\end_layout

\end_inset

 zawiera wszystkie metody rozszerzające DLINQ.
 Każda z tych metod weryfikuje parametry wejściowe w celu przekazania użytkownik
owi zrozumiałych informacji w przypadku podania błędnych parametrów.
 Następnie tworzona jest klasa realizująca wywołanie DLINQ i zwracana użytkownik
owi w celu dalszego przetwarzania (samo wykonanie podobnie jak w LINQ następuje
 dopiero wtedy gdy potrzebne są wyniki np.
 wywołanie metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ToList
\end_layout

\end_inset

, lub enumeracja).
\end_layout

\begin_layout Standard
Specjalną metodą rozszerzającą zaimplementowaną w klasie 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedEnumerable
\end_layout

\end_inset

 jest metoda 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AsDistributed
\end_layout

\end_inset

.
 Służy ona przygotowaniu kolekcji wejściowej do przetwarzania przez metody
 DLINQ.
 Jest to realizowane poprzez opakowanie kolekcji wejściowej klasą 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
DistributedEnumerableWrapper
\end_layout

\end_inset

, która przenosi zawartość kolekcji wejściowej do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
listy rozproszonej
\end_layout

\end_inset

 (wyjątkiem jest sytuacja, w której kolekcja wejściowa jest 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
listą rozproszoną
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsection
UnaryQueryOperator
\end_layout

\begin_layout Standard
Klasą bazową dla klas implementujących metody DLINQ jest 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
UnaryQueryOperator
\end_layout

\end_inset

.
 Jest to klasa, która gromadzi wszystkie metody wspólne dla metod DLINQ
 takich jak tworzenie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątków rozproszonych
\end_layout

\end_inset

 z wykorzystaniem ustawień przekazanych przez użytkownika w metodzie 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AsDistributed
\end_layout

\end_inset

, czy zebranie wyników przetwarzania z poszczególnych 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątków rozproszonych
\end_layout

\end_inset

.
 Nazwa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
UnaryQueryOperator
\end_layout

\end_inset

 wynika z faktu, że wszystkie metody DLINQ oparte na tej klasie operują
 na jednej kolekcji.
 W przypadku implementacji metod takich jak 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Union
\end_layout

\end_inset

 -- metoda odpowiadająca za połączenie dwóch kolekcji -- należałoby stworzyć
 kolejne klasy, np.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BinaryQueryOperator
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
MapReduce
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:applications-MapReduce"

\end_inset

W celu porównania pracochłonności implementacji aplikacji z użyciem bibliteki
 Bluepath i bez niej przygotowane zostały aplikacje do realizacji przetwarzania
 w modelu mapowania i redukcji zarówno w środowisku Bluepath jak i bezpośrednio
 z
\begin_inset space ~
\end_inset

wykorzystaniem platformy Windows Communication Foundation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "MSDN:WhatIsWindowsCommunicationFoundation"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: refactor tego zdania / Jakieś nazwy by się przydały na rozróżnienie
 tych dwóch aplikacji w dalszej części tekstu
\end_layout

\end_inset

.
 Założeniem aplikacji było, by kod metod 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 i 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

 dostarczany był jako kod źródłowy w języku C# w formie klasy implementującej
 odpowiedni interfejs -- 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IMapProvider
\end_layout

\end_inset

 lub 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IReduceProvider
\end_layout

\end_inset

 -- przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:applications-MapReduce-IMapProvider-IReduceProvider"

\end_inset

 i składowany razem z danymi w
\begin_inset space ~
\end_inset


\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

.
 Kompilacja kodu miała odbywać się na węzłach bezpośrednio przed wykonaniem
 metody, do zrealizowania tego celu wybrana została biblioteka CS-Script
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "CS-Script"

\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "s"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-IMapProvider-IReduceProvider"

\end_inset

Interfejsy IMapProvider i IReduceProvider
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

public interface IMapProvider 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   IEnumerable<KeyValuePair<string, string>> Map(string key, string value);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IReduceProvider 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   KeyValuePair<string, string> Reduce(string key, IEnumerable<string> values);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Koordynator
\end_layout

\begin_layout Standard
Główną klasą w aplikacji jest 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
koordynator
\end_layout

\end_inset

, który pełni rolę nadzorcy zadań (z tego powodu nazywany jest także 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
JobTrackerem
\end_layout

\end_inset

).
 Jego zadaniem jest przydzielanie zdań mapowania i redukcji podległym węzłom.
 Poniżej opisano jego implementacje z wykorzystaniem biblioteki Bluepath
 jak i w oparciu bezpośrednio o technologię WCF.
\end_layout

\begin_layout Subsubsection*
Koordynator oparty o Bluepath
\end_layout

\begin_layout Standard
W środowisku Bluepath jego zadanie sprowadzało się w pierwszej fazie przetwarzan
ia do uruchomienia 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątków rozproszonych
\end_layout

\end_inset

 w liczbie odpowiadającej liczbe plików wejściowych
\begin_inset Note Note
status open

\begin_layout Plain Layout
z tą liczbą do sprawdzenia (??)
\end_layout

\end_inset

, które były inicjowane metodą, która:
\end_layout

\begin_layout Itemize
ładowała kod metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

, 
\end_layout

\begin_layout Itemize
wykonywała skompilowany kod 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
mappera
\end_layout

\end_inset

 na wskazanym fragmencie danych wejściowych z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

,
\end_layout

\begin_layout Itemize
zapisywała wygenerowane pary klucz-wartość do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

,
\end_layout

\begin_layout Itemize
zwracała listę kluczy jako wynik wykonania 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątku rozproszonego
\end_layout

\end_inset

 do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
koordynatora
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Zainicjowane w ten sposób wątki były następnie uruchamiane z parą parametrów
 -- nazwą pliku zawierającego dane do przetworzenia oraz nazwą pliku z kodem
 źródłowym metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

.
 W drugiej fazie przetwarzania tworzonych było tyle rozproszonych wątków,
 ile kluczy było wynikiem pierwszej fazy
\begin_inset Note Note
status open

\begin_layout Plain Layout
z tą liczbą do sprawdzenia (??)
\end_layout

\end_inset

.
 Każdy z nich inicjowany był metodą, która:
\end_layout

\begin_layout Itemize
ładowała kod metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

 z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

,
\end_layout

\begin_layout Itemize
wykonywała skompilowany kod 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
reducera
\end_layout

\end_inset

 na wskazanym fragmencie danych wejściowych z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

,
\end_layout

\begin_layout Itemize
zapisywała wygenerowane pary klucz-wartość do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci rozproszonej
\end_layout

\end_inset

,
\end_layout

\begin_layout Itemize
zwracała listę kluczy jako wynik wykonania rozproszonego wątku do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
koordynatora
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Przygotowywana jest lista przydziału kluczy do przetwarzania poszczególnym
 wątkom dokonującym redukcji, po czym są one uruchamiane z parą parametrów
 -- kluczem oraz nazwą pliku z kodem źródłowym metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Koordynator w technologii WCF
\end_layout

\begin_layout Standard
W projekcie bez użycia biblioteki Bluepath koordynator jest opisany za pomocą
 interfejsu definiującego kontrakt usługi (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ServiceContract
\end_layout

\end_inset

) i udostępnia końcówkę WCF (ang.
\begin_inset space ~
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
WCF endpoint
\end_layout

\end_inset

).
 Interfejs ten został przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:applications-MapReduce-ICoordinatorService"

\end_inset

.
 W tej implementacji koordynator, oprócz zlecania wykonania zadań, musi
 również zająć się innymi zadaniami związanymi z obsługą klastra:
\end_layout

\begin_layout Itemize
rejestrowywaniem i wyrejestrowywaniem węzłów, udostępnianiem ich listy (metody
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AddWorker
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RemoveWorker
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetWorkers
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
udostępnianiem wyników przetwarzania, zarówno pełnych jak i częściowych,
 jeżeli przetwarzanie jeszcze trwa (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetResults
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
udostępnianiem interfejsu do manipulacji danymi znajdującymi się w jego
 części pamięci -- zapisywanie, usuwanie, pobieranie listy plików, czyszczenie
 pamięci (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AddToStorage
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RemoveFromStorage
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ListStorageFiles
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CleanStorage
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Pliki, które mają być przetwarzane oraz kod metod Map i Reduce muszą w pierwszej
 kolejności trafić do pamięci koordynatora.
 Poszczególne pliki są następnie wysyłane do konkretnych węzłów, którym
 przydzielone zostało zadanie ich przetwarzania.
 Podobnie po zakończeniu fazy mapowania koordynator przygotowuje plan wykonania
 fazy redukcji i rozsyła w klastrze listę przydziału kluczy do węzłów.
 Na tej podstawie węzły mogą przesłać między sobą wyniki pośrednie.
 Po zakończeniu przetwarzania węzły przesyłają pliki wynikowe do pamięci
 koordynatora.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-ICoordinatorService"

\end_inset

Interfejs ICoordinatorService
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

[ServiceContract]
\end_layout

\begin_layout Plain Layout

public interface ICoordinatorService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void AddWorker(Uri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri[] GetWorkers();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void RemoveWorker(Uri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    bool RunJob(int numberOfMappers, int numberOfReducers, Uri mapCodeFile,
 Uri reduceCodeFile, Uri[] filesToProcess);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri AddToStorage(string fileName, string content);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri[] ListStorageFiles();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void RemoveFromStorage(Uri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void CleanStorage();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    MapReduceResult GetResults();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[DataContract]
\end_layout

\begin_layout Plain Layout

public class MapReduceResult
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [DataMember]
\end_layout

\begin_layout Plain Layout

    public Tuple<string, string>[] KeysAndValues { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [DataMember]
\end_layout

\begin_layout Plain Layout

    public bool IsRunning { get; set; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pamięć masowa
\end_layout

\begin_layout Standard
Aplikacja ta korzysta z abstrakcji pamięci masowej, którą definiuje interfejs
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IMapReduceStorage
\end_layout

\end_inset

.
 Został on zaprezentowany na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:applications-MapReduce-IMapReduceStorage"

\end_inset

.
 Udostępnia on dodatkowe operacje, które umożliwiają np.
 pobieranie listy istniejących plików czy listy kluczy wygenerowanych w
 wyniku fazy mapowania.
 Interfejs ten jest wspólny dla implementacji z użyciem środowiska Bluepath
 -- wynikiem jest klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BluepathStorage
\end_layout

\end_inset

 wykorzystująca 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięć rozproszoną
\end_layout

\end_inset

 -- jak i bez niego -- w tym przypadku jest to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FileSystemStorage
\end_layout

\end_inset

 bazujący na systemie plików.
 Klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FileSystemStorage
\end_layout

\end_inset

 przed zapisaniem pliku na dysk zamienia jego nazwę na reprezentację w kodowaniu
 
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
Base64
\end_layout

\end_inset

.
 Mogło więc się zdarzyć, że w naziwe pliku pojawi się symbol ,,+''.
 Po zapisaniu tak zakodowanego klucza za pomocą klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Uri
\end_layout

\end_inset

 następowała zamiana znaku ,,+'' na spację, przez co wartość przestawała
 być poprawnym ciągiem zgodnym z
\begin_inset space ~
\end_inset

kodowaniem Base64.
 Jako rozwiązanie tego problemu zastosowano zamianę spacji z
\begin_inset space ~
\end_inset

powrotem na znaki ,,+'' w momencie odczytu klucza z otrzymanego 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Uri
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-IMapReduceStorage"

\end_inset

Interfejs IMapReduceStorage
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

public interface IMapReduceStorage
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    IEnumerable<Uri> ListFiles();
\end_layout

\begin_layout Plain Layout

    string Read(string fileName);
\end_layout

\begin_layout Plain Layout

    string Read(Uri uri);
\end_layout

\begin_layout Plain Layout

    string[] ReadLines(string fileName);
\end_layout

\begin_layout Plain Layout

    void Store(string fileName, string value);
\end_layout

\begin_layout Plain Layout

    void Store(Uri uri, string value);
\end_layout

\begin_layout Plain Layout

    void Clean();
\end_layout

\begin_layout Plain Layout

    string GetFileName(Uri uri);
\end_layout

\begin_layout Plain Layout

    IEnumerable<string> GetKeys();
\end_layout

\begin_layout Plain Layout

    void Remove(Uri uri);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Węzeł obliczeniowy w technologii WCF
\end_layout

\begin_layout Standard
Usługa węzła obliczeniowego jest komponentem obecnym jedynie w wersji aplikacji
 zbudowanej w oparciu o technologię WCF (środowisko Bluepath zapewnia możlwiość
 uruchamiania procesów roboczych na węzłach bez dodatkowego nakładu pracy
 ze strony programisty).
 Usługa ta zarządza procesami roboczymi na danym węźle oraz pełni rolę pośrednik
a między koordynatorem a procesami roboczymi.
 Węzły mogą komunikować się między sobą w celu bezpośredniego przesłania
 plików pomiędzy fazami mapowania i redukcji.
 Interfejs usługi umożliwia:
\end_layout

\begin_layout Itemize
utworzenie nowego procesu roboczego (metoda 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Init
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
uruchomienie przetwarzania w ramach jednego z procesów roboczych (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
sprawdzenie, czy przetwarzanie w danym procesie roboczym się zakończyło
 (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TryJoin
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
zlecenie przesłania plików między węzłami roboczymi na podstawie listy przydział
u kluczy do węzłów (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TransferFiles
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
zapisanie pliku w pamięci procesu roboczego (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
PushFile
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
pobranie informacji o obciążeniu węzła (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetPerformanceStatistics
\end_layout

\end_inset

) -- zajętości pamięci operacyjnej, obciążeniu procesora, ilości wolnego
 miejsca na dysku.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-IRemoteWorkerService"

\end_inset

Interfejs IRemoteWorkerService
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

[ServiceContract]
\end_layout

\begin_layout Plain Layout

public interface IRemoteWorkerService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Init(int workerId);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Map(Uri uri, Uri mapFuncUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Reduce(Uri uri, Uri reduceFuncUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    string[] TryJoin(int workerId, Uri callbackUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri[] TransferFiles(int workerId, Dictionary<string, Uri> keysAndUris);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri PushFile(int workerId, string fileName, string content);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    PerformanceMonitor.PerformanceStatistics GetPerformanceStatistics();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Uri EndpointUri { get; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wyniki eksperymentu
\end_layout

\begin_layout Standard
Implementacja środowiska do przetwarzania w modelu mapowania i redukcji
 zajęła 6
\begin_inset space ~
\end_inset

dni dwóm programistom, natomiast z wykorzystaniem biblioteki Bluepath czas
 ten skrócił się do 2
\begin_inset space ~
\end_inset

dni i to przy zaangażowaniu tylko jednego programisty, a liczba linii kodu
 została zredukowana z 585 do 194.
\end_layout

\begin_layout Section
System uzupełniania wyrazów
\end_layout

\begin_layout Standard
Wiele aplikacji operujących na dużej ilości danych próbuje wspomóc swoich
 użytkowników pozwalając filtrować dane przy pomocy zapytań tekstowych.
 Ponieważ formułowanie zapytań podlega często ograniczeniom, np.
 konieczności użycia konkretnych słów kluczowych, można stosować techniki
 wspomagające użytkownika w
\begin_inset space ~
\end_inset

tym działaniu.
 
\end_layout

\begin_layout Standard
Jedną z takich technik jest system uzupełniania wyrazów (ang.
\begin_inset space ~
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
autocomplete
\end_layout

\end_inset

).
 W trakcie wpisywania zapytania użytkownikowi prezentowana jest lista zawierając
a sugerowane zakończenia wpisywanego wyrazu.
 W przypadku gdy wyraz, który użytkownik miał zamiar wpisać, znajduje się
 na liście może on zostać wybrany.
 W
\begin_inset space ~
\end_inset

przeciwnym wpadku użytkownik musi kontynuować wpisywanie wyrazu.
\end_layout

\begin_layout Standard
System tego typu można zrealizować poprzez porównanie wprowadzonego słowa
 ze słowami występującymi w przetwarzanych danych.
 Ponieważ przetwarzanie wszystkich posiadanych danych w czasie rzeczywistym
 byłoby bardzo powolne, można je poddać wstępnej obróbce
\begin_inset space ~
\end_inset

--
\begin_inset space ~
\end_inset

np.
 wygenerowaniu i powiązaniu prefiksów z ich możliwymi rozwinięciami.
\end_layout

\begin_layout Standard
System uzupełniania wyrazów został zaimplementowany jako przykład zastosowania
 biblioteki 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
Bluepath
\end_layout

\end_inset

.
 Przetwarzanie zostało podzielone na trzy odrębne części:
\end_layout

\begin_layout Itemize
wczytywanie danych
\begin_inset space ~
\end_inset

--
\begin_inset space ~
\end_inset

wytworzenie i powiązanie prefiksów i ich rozwinięć -- opisane w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:zastosowania-autocomplete-Wczytywanie-danych"

\end_inset

,
\end_layout

\begin_layout Itemize
uzupełnianie wyrazów
\begin_inset space ~
\end_inset

--
\begin_inset space ~
\end_inset

demonstracja realizacji funkcji podpowiadania możliwych zakończeń prefiksu
 -- opisane w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:zastosowania-autocomplete-Uzupełnianie-wyrazów"

\end_inset

,
\end_layout

\begin_layout Itemize
czyszczenie stanu systemu
\begin_inset space ~
\end_inset

--
\begin_inset space ~
\end_inset

przywrócenie całego systemu do stanu początkowego bez konieczności ponownego
 uruchamiania aplikacji.
\end_layout

\begin_layout Standard
Na podział ten miały wpływ dwa czynniki:
\end_layout

\begin_layout Itemize
z założenia przygotowywanie prefiksów (wraz z rozwinięciami) miało być czynności
ą niezależną od wyszukiwania możliwych rozwinięć wpisanego wyrazu
\begin_inset space ~
\end_inset

--
\begin_inset space ~
\end_inset

system udziela odpowiedzi na podstawie najświeższych posiadanych danych,
\end_layout

\begin_layout Itemize
w trakcie pisania systemu okazało się, że przydatna jest metoda przywracająca
 system do stanu początkowego, a niebędąca częścią głównego przetwarzania.
\end_layout

\begin_layout Subsection
Wczytywanie danych
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:zastosowania-autocomplete-Wczytywanie-danych"

\end_inset

Zaimplementowany system uzupełniania wyrazów, przed rozpoczęciem wyszukiwania
 możliwych zakończeń zadanego prefiksu, musi zostać zainicjalizowany.
 Dokumenty zawierające przykładowe słowa są wczytywane przez węzeł inicjalizując
y operację wczytywania danych i dodawane jako elementy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
listy rozproszonej
\end_layout

\end_inset

.
 Następnie każdy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątek rozproszony
\end_layout

\end_inset

 pobiera nieprzetworzony fragment listy i na podstawie zawartych w nim dokumentó
w uzupełnia słownik prefiksów i możliwych dla nich uzupełnień.
 Gdy na liście nie ma już elementów do przetworzenia, 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątek rozproszony
\end_layout

\end_inset

 kończy przetwarzanie.
 Gdy wszystkie 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątki rozproszone
\end_layout

\end_inset

 zakończą przetwarzanie, każdy z węzłów zawiera częściową informację dotyczącą
 prefiksów i ich uzupełnień.
 Fragment funkcji 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
LoadDocuments
\end_layout

\end_inset

 odpowiedzialnej za operację wczytywania danych wykonywaną przez 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątek rozproszony
\end_layout

\end_inset

 został przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Fragment-funkcji-LoadDocuments"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Fragment-funkcji-LoadDocuments"

\end_inset

Fragment funkcji LoadDocuments
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

private static int LoadDocuments(string inputKey, string counterKey, int
 chunkSize, IBluepathCommunicationFramework bluepath)        
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var inputList = new DistributedList<string>(bluepath.Storage as IExtendedStorage
, inputKey);
\end_layout

\begin_layout Plain Layout

	var inputCount = inputList.Count;
\end_layout

\begin_layout Plain Layout

	var counter = new DistributedCounter(bluepath.Storage as IExtendedStorage,
 counterKey);
\end_layout

\begin_layout Plain Layout

	int indexEnd = 0;
\end_layout

\begin_layout Plain Layout

	do
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		int noOfElements = chunkSize; 
\end_layout

\begin_layout Plain Layout

		int indexStart = counter.GetAndIncrease(chunkSize); 
\end_layout

\begin_layout Plain Layout

		[...]
\end_layout

\begin_layout Plain Layout

		var inputDocuments = new string[noOfElements];    
\end_layout

\begin_layout Plain Layout

		inputList.CopyPartTo(indexStart, noOfElements, inputDocuments); 
\end_layout

\begin_layout Plain Layout

		foreach (var document in inputDocuments)     
\end_layout

\begin_layout Plain Layout

		{               
\end_layout

\begin_layout Plain Layout

			var words = document.Split(' ');    
\end_layout

\begin_layout Plain Layout

			foreach (var word in words)   
\end_layout

\begin_layout Plain Layout

			{                     
\end_layout

\begin_layout Plain Layout

				[...] // wygenerowanie prefiksów i zapisanie ich w pamięci lokalnej   
               
\end_layout

\begin_layout Plain Layout

			}                 
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} while (indexEnd <= inputCount);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return 0;     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uzupełnianie wyrazów
\begin_inset CommandInset label
LatexCommand label
name "sub:zastosowania-autocomplete-Uzupełnianie-wyrazów"

\end_inset


\end_layout

\begin_layout Standard
Głównym celem systemu uzupełniania wyrazów jest wyszukiwania możliwych zakończeń
 zadanego prefiksu.
 W tym celu należy przeszukać informacje posiadane przez każdy z węzłów,
 a następnie zagregować uzyskane wyniki częściowe.
 Aby mieć pewność, że każdy węzeł zostanie przeszukany zastosowano planistę
 szeregującego zadania za pomocą algorytmu karuzelowego (opisanego w punkcie
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Implementacja-Szeregowanie-karuzelowy"

\end_inset

) i uruchomiono tyle 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątków rozproszonych
\end_layout

\end_inset

, ile znajduje się węzłów w systemie.
 Inicjalizacja planisty została przedstawiona na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:zastosowania-autocomplete-Inicjalizacja-planisty-szeregują"

\end_inset

.
 
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:zastosowania-autocomplete-Inicjalizacja-planisty-szeregują"

\end_inset

Inicjalizacja planisty szeregującego zadania za pomocą algorytmu karuzelowego
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var services = connectionManager.RemoteServices.Select(s => s.Key).ToArray();
\end_layout

\begin_layout Plain Layout

var scheduler = new RoundRobinLocalScheduler(services);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Po zakończeniu przetwarzania przez wszystkie wątki należy zagregować dane.
 Częścią tej operacji, oprócz połączenia wyników, jest usunięcie duplikatów,
 które mogą się pojawić ze względu na to, że w tej implementacji każdy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątek rozproszony
\end_layout

\end_inset

 wykonuje przetwarzanie lokalnie (niezależnie od pozostałych wątków).
 Na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:zastosowania-autocomplete-Zebranie-wyników-w"

\end_inset

 przedstawiono zbieranie wyników oraz usunięcie duplikatów.
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C},numbers=left"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:zastosowania-autocomplete-Zebranie-wyników-w"

\end_inset

Zebranie wyników w systemie uzupełniania wyrazów
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var joinedResult = new List<string>();
\end_layout

\begin_layout Plain Layout

foreach (var thread in threads)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	thread.Join();
\end_layout

\begin_layout Plain Layout

	joinedResult.AddRange(thread.Result as string[]);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var endResult = joinedResult.Distinct().ToArray();
\end_layout

\end_inset


\end_layout

\begin_layout Section
Obliczanie przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Przykladowe-zastosowania-liczba-pi"

\end_inset

Metoda Monte Carlo
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://mathfaculty.fullerton.edu/mathews/n2003/montecarlopimod.html
\end_layout

\end_inset

 jest formą symulacji z wykorzystaniem generatora liczb pseudolosowych.
 Każde kolejne uruchomienie algorytmu daje nieco inne wyniki, o ile nie
 zapewnimy generatorowi takich samych warunków początkowych (ang.
\begin_inset space ~
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
seed
\end_layout

\end_inset

).
 Obliczenie przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset

 sprowadza się do losowania 
\begin_inset Formula $n$
\end_inset

 razy pary liczb 
\begin_inset Formula $(x,\thinspace y)$
\end_inset

 z
\begin_inset space ~
\end_inset

przedziału 
\begin_inset Formula $[0,\thinspace1]$
\end_inset

 i inkrementowaniu licznika 
\begin_inset Formula $m$
\end_inset

, gdy para spełnia warunek 
\begin_inset Formula $x^{2}+y^{2}\leq1$
\end_inset

.
 W przykładowej symulacji dla 
\begin_inset Formula $n=1000000$
\end_inset

 otrzymano 
\begin_inset Formula $m=785930$
\end_inset

.
 Oznacza to, że 
\begin_inset Formula $m$
\end_inset

 z 
\begin_inset Formula $n$
\end_inset

 sprawdzonych punków znalazło się w obszarze reprezentującym 
\begin_inset Formula $\frac{1}{4}$
\end_inset

 powierzchni koła, którego środek znajduje się w punkcie (0, 0) -- patrz
 rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:applications-Monte-Carlo-Pi"

\end_inset

.
 Ostateczne wyliczenie otrzymanego przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset

 przedstawia równanie 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:applications-Monte-Carlo-Pi"

\end_inset

.
 
\begin_inset Formula 
\begin{equation}
p=\frac{m}{n}=\frac{785930}{1000000},\thinspace\thinspace\thinspace p\times4=3,14372\approx\pi\label{eq:applications-Monte-Carlo-Pi}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset External
	template RasterImage
	filename images/monte-carlo-pi.png
	lyxscale 30
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:applications-Monte-Carlo-Pi"

\end_inset

Ilustracja obliczania przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset

 metodą Monte Carlo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zwiększanie liczby próbek 
\begin_inset Formula $n$
\end_inset

 nie musi poprawiać dokładności otrzymanego wyniku.
 W zależności od jakości zastosowanego generatora liczb pseudolosowych,
 może on w pewnym momencie zakończyć bieżącą sekwencję i rozpocząć zwracanie
 liczb z tej samej sekwencji od początku.
 Ponieważ celem tego testu nie jest zbadanie dokładności przybliżenia liczby
 
\begin_inset Formula $\pi$
\end_inset

 a porównanie szybkości obliczeń w klastrze i na pojedynczym węźle, jako
 generator została wybrana klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Random
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Implementacja klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Random
\end_layout

\end_inset

 w .NET Framework 4.0 posiada kilka cech, które sprawiają, że nie nadaje się
 ona do zastosowań, w których oczekujemy ciągu o wysokim stopniu losowości.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://stackoverflow.com/a/6842191
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inicjowanie generatora przez domyślny konstruktor używa aktualnego czasu.
 Z tego powodu utworzenie wielu jego instancji w krótkim czasie, np.
 w środowisku wielowątkowym, może prowadzić do otrzymania takich samych
 sekwencji liczb.
 Co więcej, przestrzeń inicujująca generator jest stosunkowo mała -- mając
 już 
\begin_inset Formula $2^{16}$
\end_inset

 instancji generatora zainicjowanego losowymi wartościami istnieje duże
 prawdopodobieństwo otrzymania tej samej sekwencji wielokrotnie.
\end_layout

\begin_layout Itemize
Dla niektórych wartości parametrów metoda 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Next
\end_layout

\end_inset

 zwraca sekwencje, których rozkład nie jest równomierny.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
dla r.Next(1431655765)%2 ok.
 2/3 próbek to 0 -> 2/3 próbek to liczby parzyste
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
W zastosowaniach, w których wymagane jest bezpieczeństwo zaleca się stosowanie
 implementacji opartych o metody kryptograficzne, np.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Security.Cryptography.RNGCryptoServiceProvider
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Otrzymane wyniki i ich analiza zostały przedstawione w rozdziale 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
Testy wydajnościowe i jakościowe
\end_layout

\end_inset

 w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:performance-Obliczanie-przyblizenia-Pi"

\end_inset

.
\end_layout

\end_body
\end_document
