#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass dcsbook
\use_default_options true
\begin_modules
dcs
\end_modules
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Przykładowe zastosowania
\end_layout

\begin_layout Standard
W tym rozdziale przedstawione zostaną przykladowe zastosowania systemu Bluepath.
 Na bazie rozproszonych wątków, współdzielonej rozproszonej pamięci i nadbudowan
ych nad nią abstrakcji listy i słownika przygotowane zostały projekty:
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
DLINQ
\end_layout

\end_inset

 (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
Distributed Language Integrated Query
\end_layout

\end_inset

) -- dostawca metod manipulacji kolekcji w sposób zgodny z obecnym już w
 środowisku .NET dla standardowych, nierozproszonych kolekcji, 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
MapReduce
\end_layout

\end_inset

 -- abstrakcja specjalizowana do uruchamiania zadań w modelu mapowania i
 redukcji z możliwością zlecania zadań bez rekompilacji systemu i dystrybuowania
 nowej wersji plików wykonywalnych na węzły -- kod metod 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 i 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

 jest pobierany ze współdzielonej pamięci i kompilowany przed wykonaniem
 na węzłach, 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
Generowanie słownika prefiksów
\end_layout

\end_inset

 -- algorytm przygotowujący na podstawie podanej kolekcji dokumentów bazę
 prefiksów, która może zostać wykorzystana do zrealizowania systemu podpowiedzi
 słów na podstawie pierwszych liter wpisywanych przez użytkownika,
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
Obliczanie przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset


\end_layout

\end_inset

 -- algorytm obliczający przybliżoną wartość liczby 
\begin_inset Formula $\pi$
\end_inset

, który umożliwił przeprowadzenie testów porównawczych szybkości obliczeń
 w klastrze bez wykorzystania pamięci współdzielonej w stosunku do obliczeń
 prowadzonych na pojedynczym węźle.
\end_layout

\begin_layout Section
DLINQ
\end_layout

\begin_layout Standard
Jedną z aplikacji zaimplementowanych na bazie biblioteki Bluepath jest Distribut
ed Language Integrated Query (DLINQ) -- zbiór metod roszerzających możliwości
 operowania na kolekcjach bazowanych na 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Obecna implementacja służy jako przykład (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
proof of concept
\end_layout

\end_inset

) wykorzystania możliwości dostarczanych przez bibliotekę Bluepath i dlatego
 dostarcza podzbioru metod standardowego zestawu LINQ:
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

 -- operacja ta pozwala przetransformować obiekt, np.
 wybierając jedynie podzbiór jego atrybutów, lub zmieniając typ obiektu,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
SelectMany
\end_layout

\end_inset

 -- operacja podobna do 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

 z tą różnicą, że pojedynczy obiekt w wyniku transformacji zmieniany jest
 w kolekcję obiektów, a powstałe w ten sposób kolekcje są łączone w jedną,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Where
\end_layout

\end_inset

 -- operacja ta pozwala wyfiltrować te obiekty, które spełniają podany warunek,
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GroupBy
\end_layout

\end_inset

 -- operacja pozwalająca grupować obiekty według zadanego klucza.
 
\end_layout

\begin_layout Standard
Operacje te mogą być wykonywane zarówno na dostarczonej z biblioteką Bluepath
 liście rozproszonej (opisanej w 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:----Koncepcja-wspoldzielone-struktury-danych"

\end_inset

) jak i na wszystkich obiektach implementujących interfejs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IEnumerable
\end_layout

\end_inset

.
 W drugim przypadku kolekcja źródłowa zostanie najpierw przetransformowana
 do listy rozproszonej, a następnie poddana dalszemu przetwarzaniu.
\end_layout

\begin_layout Standard
Sposób wykorzystania rozszerzeń DLINQ jest wzorowany na Parallel Language
 Integrated Query (PLINQ).
 Aby poddać kolekcję przetwarzaniu rozproszonemu wykonujemy najpierw metodę
 rozszerzającą 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AsDistributed
\end_layout

\end_inset

.
 Metoda ta posiada jeden obowiązkowy argument - obiekt zapewniający dostęp
 do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięci współdzielonej
\end_layout

\end_inset

.
 Następnie na otrzymanym z tej metody obiekcie można wykonywać operacje
 zdefiniowane w DLINQ.
 Należy jednak mieć na uwadze, że operacje te podlegają założeniom biblioteki
 Bluepath i funkcje podawane jako argumenty muszą być funkcjami statycznymi.
 Na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Transformacja-kolekcji-DLINQ"

\end_inset

 przedstawiono przykładowy kod poddający kolekcję transformacji przy użyciu
 metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Select
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Transformacja-kolekcji-DLINQ"

\end_inset

Transformacja kolekcji przypomocy metod dostarczonych w DLINQ
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

var inputCollection = new List<double>(100);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

var processedCollection = (from num in inputCollection.AsDistributed(storage)
\end_layout

\begin_layout Plain Layout

							select Math.Sqrt(num)).ToList();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Częściowa implementacja proof of concept
\end_layout

\begin_layout Plain Layout
AsDistributed -- co właściwie robi?
\end_layout

\begin_layout Plain Layout
GroupBy, SelectMany, Select, Where
\end_layout

\end_inset


\end_layout

\begin_layout Section
MapReduce
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:applications-MapReduce"

\end_inset

W celu porównania pracochłonności implementacji aplikacji z użyciem bibliteki
 Bluepath i bez niej przygotowane zostały aplikacje do realizacji przetwarzania
 w modelu mapowania i redukcji zarówno w środowisku Bluepath jak i bezpośrednio
 z wykorzystaniem platformy Windows Communication Foundation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "MSDN:WhatIsWindowsCommunicationFoundation"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: refactor tego zdania / Jakieś nazwy by się przydały na rozróżnienie
 tych dwóch aplikacji w dalszej części tekstu
\end_layout

\end_inset

.
 Założeniem aplikacji było, by kod metod 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 i 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

 dostarczany był jako kod źródłowy w języku C# w formie klasy implementującej
 odpowiedni interfejs -- 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IMapProvider
\end_layout

\end_inset

 lub 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IReduceProvider
\end_layout

\end_inset

 -- przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:applications-MapReduce-IMapProvider-IReduceProvider"

\end_inset

 i składowany razem z danymi w pamięci współdzielonej.
 Kompilacja kodu miała odbywać się na węzłach bezpośrednio przed wykonaniem
 metody, do zrealizowania tego celu wybrana została biblioteka CS-Script
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "CS-Script"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Innym podejściem mogłoby być dostarczanie kodu w formie bibliotek dołączanych
 dynamicznie (ang.
\begin_inset space ~
\end_inset


\begin_inset Flex Emph
status open

\begin_layout Plain Layout
.NET
\begin_inset space ~
\end_inset

assembly
\end_layout

\end_inset

).
 Rozwiązanie zostało odrzucone z powodu potencjalnych komplikacji związanych
 z wyładowywaniem kodu z pamięci przed rozpoczęciem kolejnego zadania (patrz
 punkt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:problemy-Wyladowywanie-kodu-z-pamieci"

\end_inset

), a
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
piszemy o tym? więcej w problemach? były małe testy z addonami.
 I czy na pewno wyładowujemy tak jak trzeba? :D http://www.csscript.net/help/scrip
t_hosting_guideline_.html (nie potrzeba AsmHelper?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
i czy metoda Reduce nie powinna zwracać IEnumerable<KeyValuePair<..,..>>?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-IMapProvider-IReduceProvider"

\end_inset

Interfejsy IMapProvider i IReduceProvider
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

public interface IMapProvider 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   IEnumerable<KeyValuePair<string, string>> Map(string key, string value);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface IReduceProvider 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   KeyValuePair<string, string> Reduce(string key, IEnumerable<string> values);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Koordynator
\end_layout

\begin_layout Standard
Główną klasą w aplikacji jest 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
koordynator
\end_layout

\end_inset

, który pełni rolę nadzorcy zadań (z tego powodu nazywany jest także 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
JobTrackerem
\end_layout

\end_inset

).
 Jego zadaniem jest przydzielanie zdań mapowania i redukcji podległym węzłom.
 Poniżej opisano jego implementacje z wykorzystaniem biblioteki Bluepath
 jak i w oparciu bezpośrednio o technologię WCF.
\end_layout

\begin_layout Subsubsection*
Koordynator oparty o Bluepath
\end_layout

\begin_layout Standard
W środowisku Bluepath jego zadanie sprowadzało się w pierwszej fazie przetwarzan
ia do uruchomienia 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
rozproszonych wątków
\end_layout

\end_inset

 w liczbie odpowiadającej liczbe plików wejściowych
\begin_inset Note Note
status open

\begin_layout Plain Layout
z tą liczbą do sprawdzenia (??)
\end_layout

\end_inset

, które były inicjowane metodą, która:
\end_layout

\begin_layout Itemize
ładowała kod metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

 ze współdzielonej pamięci, 
\end_layout

\begin_layout Itemize
wykonywała skompilowany kod 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
mappera
\end_layout

\end_inset

 na wskazanym fragmencie danych wejściowych ze współdzielonej pamięci,
\end_layout

\begin_layout Itemize
zapisywała wygenerowane pary klucz--wartość do współdzielonej pamięci,
\end_layout

\begin_layout Itemize
zwracała listę kluczy jako wynik wykonania rozproszonego wątku do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
koordynatora
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Zainicjowane w ten sposób wątki były następnie uruchamiane z parą parametrów
 -- nazwą pliku zawierającego dane do przetworzenia oraz nazwą pliku z kodem
 źródłowym metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

.
 W drugiej fazie przetwarzania tworzonych było tyle rozproszonych wątków,
 ile kluczy było wynikiem pierwszej fazy
\begin_inset Note Note
status open

\begin_layout Plain Layout
z tą liczbą do sprawdzenia (??)
\end_layout

\end_inset

.
 Każdy z nich inicjowany był metodą, która:
\end_layout

\begin_layout Itemize
ładowała kod metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

 ze współdzielonej pamięci,
\end_layout

\begin_layout Itemize
wykonywała skompilowany kod 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
reducera
\end_layout

\end_inset

 na wskazanym fragmencie danych wejściowych ze współdzielonej pamięci,
\end_layout

\begin_layout Itemize
zapisywała wygenerowane pary klucz--wartość do współdzielonej pamięci,
\end_layout

\begin_layout Itemize
zwracała listę kluczy jako wynik wykonania rozproszonego wątku do 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
koordynatora
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Przygotowywana jest lista przydziału kluczy do przetwarzania poszczególnym
 wątkom dokonującym redukcji, po czym są one uruchamiane z parą parametrów
 -- kluczem oraz nazwą pliku z kodem źródłowym metody 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Koordynator w technologii WCF
\end_layout

\begin_layout Standard
W projekcie bez użycia biblioteki Bluepath koordynator jest opisany za pomocą
 interfejsu definiującego kontrakt usługi (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ServiceContract
\end_layout

\end_inset

) i udostępnia końcówkę WCF (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
WCF endpoint
\end_layout

\end_inset

).
 Interfejs ten został przedstawiony na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:applications-MapReduce-ICoordinatorService"

\end_inset

.
 W tej implementacji koordynator, oprócz zlecania wykonania zadań, musi
 również zająć się innymi zadaniami związanymi z obsługą klastra:
\end_layout

\begin_layout Itemize
rejestrowywaniem i wyrejestrowywaniem węzłów, udostępnianiem ich listy (metody
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AddWorker
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RemoveWorker
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetWorkers
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
udostępnianiem wyników przetwarzania, zarówno pełnych jak i częściowych,
 jeżeli przetwarzanie jeszcze trwa (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetResults
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
udostępnianiem interfejsu do manipulacji danymi znajdującymi się w jego
 części pamięci -- zapisywanie, usuwanie, pobieranie listy plików, czyszczenie
 pamięci (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
AddToStorage
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
RemoveFromStorage
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ListStorageFiles
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
CleanStorage
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Pliki, które mają być przetwarzane oraz kod metod Map i Reduce muszą w pierwszej
 kolejności trafić do pamięci koordynatora.
 Poszczególne pliki są następnie wysyłane do konkretnych węzłów, którym
 przydzielone zostało zadanie ich przetwarzania.
 Podobnie po zakończeniu fazy mapowania koordynator przygotowuje plan wykonania
 fazy redukcji i rozsyła w klastrze listę przydziału kluczy do węzłów.
 Na tej podstawie węzły mogą przesłać między sobą wyniki pośrednie.
 Po zakończeniu przetwarzania węzły przesyłają pliki wynikowe do pamięci
 koordynatora.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-ICoordinatorService"

\end_inset

Interfejs ICoordinatorService
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

[ServiceContract]
\end_layout

\begin_layout Plain Layout

public interface ICoordinatorService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void AddWorker(Uri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri[] GetWorkers();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void RemoveWorker(Uri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    bool RunJob(int numberOfMappers, int numberOfReducers, Uri mapCodeFile,
 Uri reduceCodeFile, Uri[] filesToProcess);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri AddToStorage(string fileName, string content);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri[] ListStorageFiles();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void RemoveFromStorage(Uri uri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void CleanStorage();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    MapReduceResult GetResults();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[DataContract]
\end_layout

\begin_layout Plain Layout

public class MapReduceResult
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [DataMember]
\end_layout

\begin_layout Plain Layout

    public Tuple<string, string>[] KeysAndValues { get; set; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [DataMember]
\end_layout

\begin_layout Plain Layout

    public bool IsRunning { get; set; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pamięć masowa
\end_layout

\begin_layout Standard
Aplikacja ta korzysta z abstrakcji pamięci masowej, którą definiuje interfejs
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
IMapReduceStorage
\end_layout

\end_inset

.
 Został on zaprezentowany na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:applications-MapReduce-IMapReduceStorage"

\end_inset

.
 Udostępnia on dodatkowe operacje, które umożliwiają np.
 pobieranie listy istniejących plików czy listy kluczy wygenerowanych w
 wyniku fazy mapowania.
 Interfejs ten jest wspólny dla implementacji z użyciem środowiska Bluepath
 -- wynikiem jest klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
BluepathStorage
\end_layout

\end_inset

 wykorzystująca współdzieloną pamięć -- jak i bez niego -- w tym przypadku
 jest to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FileSystemStorage
\end_layout

\end_inset

 bazujący na systemie plików.
 Klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FileSystemStorage
\end_layout

\end_inset

 przed zapisaniem pliku na dysk zamienia jego nazwę na reprezentację w kodowaniu
 
\begin_inset Flex Strong
status open

\begin_layout Plain Layout
Base64
\end_layout

\end_inset

.
 Mogło więc się zdarzyć, że w naziwe pliku pojawi się symbol ,,+''.
 Po zapisaniu tak zakodowanego klucza za pomocą klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Uri
\end_layout

\end_inset

 następowała zamiana znaku ,,+'' na spację, przez co wartość przestawała
 być poprawnym ciągiem zgodnym z kodowaniem Base64.
 Jako rozwiązanie tego problemu zastosowano zamianę spacji z powrotem na
 znaki ,,+'' w momencie odczytu klucza z otrzymanego 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Uri
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-IMapReduceStorage"

\end_inset

Interfejs IMapReduceStorage
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

public interface IMapReduceStorage
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    IEnumerable<Uri> ListFiles();
\end_layout

\begin_layout Plain Layout

    string Read(string fileName);
\end_layout

\begin_layout Plain Layout

    string Read(Uri uri);
\end_layout

\begin_layout Plain Layout

    string[] ReadLines(string fileName);
\end_layout

\begin_layout Plain Layout

    void Store(string fileName, string value);
\end_layout

\begin_layout Plain Layout

    void Store(Uri uri, string value);
\end_layout

\begin_layout Plain Layout

    void Clean();
\end_layout

\begin_layout Plain Layout

    string GetFileName(Uri uri);
\end_layout

\begin_layout Plain Layout

    IEnumerable<string> GetKeys();
\end_layout

\begin_layout Plain Layout

    void Remove(Uri uri);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Węzeł obliczeniowy w technologii WCF
\end_layout

\begin_layout Standard
Usługa węzła obliczeniowego jest komponentem obecnym jedynie w wersji aplikacji
 zbudowanej w oparciu o technologię WCF (środowisko Bluepath zapewnia możlwiość
 uruchamiania procesów roboczych na węzłach bez dodatkowego nakładu pracy
 ze strony programisty).
 Usługa ta zarządza procesami roboczymi na danym węźle oraz pełni rolę pośrednik
a między koordynatorem a procesami roboczymi.
 Węzły mogą komunikować się między sobą w celu bezpośredniego przesłania
 plików pomiędzy fazami mapowania i redukcji.
 Interfejs usługi umożliwia:
\end_layout

\begin_layout Itemize
utworzenie nowego procesu roboczego (metoda 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Init
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
uruchomienie przetwarzania w ramach jednego z procesów roboczych (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Map
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Reduce
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
sprawdzenie, czy przetwarzanie w danym procesie roboczym się zakończyło
 (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TryJoin
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
zlecenie przesłania plików między węzłami roboczymi na podstawie listy przydział
u kluczy do węzłów (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TransferFiles
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
zapisanie pliku w pamięci procesu roboczego (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
PushFile
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
pobranie informacji o obciążeniu węzła (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
GetPerformanceStatistics
\end_layout

\end_inset

) -- zajętości pamięci operacyjnej, obciążeniu procesora, ilości wolnego
 miejsca na dysku.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language={[Sharp]C}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:applications-MapReduce-IRemoteWorkerService"

\end_inset

Interfejs IRemoteWorkerService
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

[ServiceContract]
\end_layout

\begin_layout Plain Layout

public interface IRemoteWorkerService
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Init(int workerId);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Map(Uri uri, Uri mapFuncUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    void Reduce(Uri uri, Uri reduceFuncUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    string[] TryJoin(int workerId, Uri callbackUri);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri[] TransferFiles(int workerId, Dictionary<string, Uri> keysAndUris);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    Uri PushFile(int workerId, string fileName, string content);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    [OperationContract]
\end_layout

\begin_layout Plain Layout

    PerformanceMonitor.PerformanceStatistics GetPerformanceStatistics();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Uri EndpointUri { get; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wyniki eksperymentu
\end_layout

\begin_layout Standard
Implementacja środowiska do przetwarzania w modelu mapowania i redukcji
 zajęła 6
\begin_inset space ~
\end_inset

dni dwóm programistom, natomiast z wykorzystaniem biblioteki Bluepath czas
 ten skrócił się do 2
\begin_inset space ~
\end_inset

dni
\begin_inset Note Note
status open

\begin_layout Plain Layout
4?
\end_layout

\end_inset

 i to przy zaangażowaniu tylko jednego programisty.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
może jakieś zestawienie 'co trzeba zakodzić - Bluepath vs.
 WCF'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Generowanie słownika prefiksów
\end_layout

\begin_layout Standard
Wiele aplikacji operujących na dużej liczbie danych próbuje wspomóc swoich
 użytkowników pozwalając filtrować dane przy pomocy zapytań tekstowych.
 Ponieważ formułowanie zapytań podlega często ograniczeniom, np.
 konieczności użycia konkretnych słów kluczowych, można stosować techniki
 wspomagające użytkownika w tym działaniu.
 
\end_layout

\begin_layout Standard
Jedną z takich technik jest system automatycznego uzupełniania (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
autocomplete
\end_layout

\end_inset

).
 Można go zrealizować poprzez porównanie wprowadzonego słowa z słowami występują
cymi w przetwarzanych danych.
 Ponieważ przetwarzanie wszystkich posiadanych danych w czasie rzeczywistym
 byłoby bardzo powolne, można je poddać wstępnej obróbce -- np.
 wytworzenie wszystkich możliwych prefiksów.
\end_layout

\begin_layout Standard
System generujący wszystkie możliwe prefiksy na podstawie zadanych danych
 został zaimplementowany jako przykład zastosowania biblioteki Bluepath.
 Przetwarzanie zostało oparte o kolekcję dokumentów, która jest rozsyłana
 do poszczególnych węzłów (każdy 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
wątek rozproszony
\end_layout

\end_inset

 łączy się z 
\begin_inset Flex Name
status open

\begin_layout Plain Layout
pamięcią współdzieloną
\end_layout

\end_inset

, z której pobiera dokumenty, które ma przetworzyć).
 Po przetworzeniu wszystkich dokumentów wszystkie prefiksy są zachowywane
 lokalnie w celu późniejszego wykorzystania przy wyszukiwaniu (wyszukiwany
 prefiks jest rozsyłany do wszystkich węzłów przetwarzających).
\end_layout

\begin_layout Section
Obliczanie przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Przykladowe-zastosowania-liczba-pi"

\end_inset

Metoda Monte Carlo
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://mathfaculty.fullerton.edu/mathews/n2003/montecarlopimod.html
\end_layout

\end_inset

 jest formą symulacji z wykorzystaniem generatora liczb pseudolosowych.
 Każde kolejne uruchomienie algorytmu daje nieco inne wyniki, o ile nie
 zapewnimy generatorowi takich samych warunków początkowych (ang.
 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
seed
\end_layout

\end_inset

).
 Obliczenie przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset

 sprowadza się do losowania 
\begin_inset Formula $n$
\end_inset

 razy pary liczb 
\begin_inset Formula $(x,\thinspace y)$
\end_inset

 z przedziału 
\begin_inset Formula $[0,\thinspace1]$
\end_inset

 i inkrementowaniu licznika 
\begin_inset Formula $m$
\end_inset

, gdy para spełnia warunek 
\begin_inset Formula $x^{2}+y^{2}\leq1$
\end_inset

.
 W przykładowej symulacji dla 
\begin_inset Formula $n=1000000$
\end_inset

 otrzymano 
\begin_inset Formula $m=785930$
\end_inset

.
 Oznacza to, że 
\begin_inset Formula $m$
\end_inset

 z 
\begin_inset Formula $n$
\end_inset

 sprawdzonych punków znalazło się w obszarze reprezentującym 
\begin_inset Formula $\frac{1}{4}$
\end_inset

 powierzchni koła, którego środek znajduje się w punkcie (0, 0) -- patrz
 rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:applications-Monte-Carlo-Pi"

\end_inset

.
 Ostateczne wyliczenie otrzymanego przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset

 przedstawia równanie 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:applications-Monte-Carlo-Pi"

\end_inset

.
 
\begin_inset Formula 
\begin{equation}
p=\frac{m}{n}=\frac{785930}{1000000},\thinspace\thinspace\thinspace p\times4=3,14372\approx\pi\label{eq:applications-Monte-Carlo-Pi}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Zwiększanie liczby próbek 
\begin_inset Formula $n$
\end_inset

 nie musi poprawiać dokładności otrzymanego wyniku.
 W zależności od jakości zastosowanego generatora liczb pseudolosowych,
 może on w pewnym momencie zakończyć bieżącą sekwencję i rozpocząć zwracanie
 liczb z tej samej sekwencji od początku.
 Ponieważ celem tego testu nie jest zbadanie dokładności przybliżenia liczby
 
\begin_inset Formula $\pi$
\end_inset

 a porównanie szybkości obliczeń w klastrze i na pojedynczym węźle, jako
 generator została wybrana klasa 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Random
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Implementacja klasy 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Random
\end_layout

\end_inset

 w .NET Framework 4.0 posiada kilka cech, które sprawiają, że nie nadaje się
 ona do zastosowań, w których oczekujemy ciągu o wysokim stopniu losowości.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://stackoverflow.com/a/6842191
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inicjowanie generatora przez domyślny konstruktor używa aktualnego czasu.
 Z tego powodu utworzenie wielu jego instancji w krótkim czasie, np.
 w środowisku wielowątkowym, może prowadzić do otrzymania takich samych
 sekwencji liczb.
 Co więcej, przestrzeń inicujująca generator jest stosunkowo mała -- mając
 już 
\begin_inset Formula $2^{16}$
\end_inset

 instancji generatora zainicjowanego losowymi wartościami istnieje duże
 prawdopodobieństwo otrzymania tej samej sekwencji wielokrotnie.
\end_layout

\begin_layout Itemize
Dla niektórych wartości parametrów metoda 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
Next
\end_layout

\end_inset

 zwraca sekwencje, których rozkład nie jest równomierny.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
dla r.Next(1431655765)%2 ok.
 2/3 próbek to 0 -> 2/3 próbek to liczby parzyste
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
W zastosowaniach, w których wymagane jest bezpieczeństwo zaleca się stosowanie
 implementacji opartych o metody kryptograficzne, np.
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
System.Security.Cryptography.RNGCryptoServiceProvider
\end_layout

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Otrzymane wyniki i ich analiza zostały przedstawione w rozdziale 
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
Testy wydajnościowe i jakościowe
\end_layout

\end_inset

 w punkcie 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:performance-Obliczanie-przyblizenia-Pi"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset External
	template RasterImage
	filename images/monte-carlo-pi.png
	lyxscale 30
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:applications-Monte-Carlo-Pi"

\end_inset

Ilustracja obliczania przybliżenia liczby 
\begin_inset Formula $\pi$
\end_inset

 metodą Monte Carlo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
